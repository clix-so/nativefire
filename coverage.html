
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/clix-so/nativefire/cmd/configure.go (21.9%)</option>
				
				<option value="file1">github.com/clix-so/nativefire/cmd/projects.go (5.7%)</option>
				
				<option value="file2">github.com/clix-so/nativefire/cmd/root.go (70.6%)</option>
				
				<option value="file3">github.com/clix-so/nativefire/cmd/version.go (100.0%)</option>
				
				<option value="file4">github.com/clix-so/nativefire/internal/firebase/firebase.go (24.2%)</option>
				
				<option value="file5">github.com/clix-so/nativefire/internal/logger/logger.go (0.0%)</option>
				
				<option value="file6">github.com/clix-so/nativefire/internal/platform/android.go (47.0%)</option>
				
				<option value="file7">github.com/clix-so/nativefire/internal/platform/desktop.go (12.5%)</option>
				
				<option value="file8">github.com/clix-so/nativefire/internal/platform/ios.go (10.2%)</option>
				
				<option value="file9">github.com/clix-so/nativefire/internal/platform/platform.go (92.3%)</option>
				
				<option value="file10">github.com/clix-so/nativefire/internal/ui/colors.go (70.0%)</option>
				
				<option value="file11">github.com/clix-so/nativefire/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/clix-so/nativefire/internal/firebase"
        "github.com/clix-so/nativefire/internal/platform"
        "github.com/clix-so/nativefire/internal/ui"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        projectID    string
        platformFlag string
        autoDetect   bool
        appID        string
        bundleID     string
        packageName  string
)

var configureCmd = &amp;cobra.Command{
        Use:   "configure",
        Short: "üöÄ Configure Firebase for your native application",
        Long: ui.Primary.Sprint("üöÄ Firebase Configuration Wizard\n\n") +
                "Automatically configure Firebase for your native application with smart detection and setup.\n\n" +
                ui.Bold.Sprint("Features:") + "\n" +
                "  ‚Ä¢ " + ui.Platform("üì±") + " Multi-platform support (iOS, Android, macOS, Windows, Linux)\n" +
                "  ‚Ä¢ üéØ Smart project and platform detection\n" +
                "  ‚Ä¢ üì¶ Automatic config file placement\n" +
                "  ‚Ä¢ üîß Code injection for Firebase initialization\n" +
                "  ‚Ä¢ üîç Bundle ID and Package Name auto-detection\n\n" +
                ui.Bold.Sprint("Quick Examples:") + "\n" +
                "  " + ui.Code("nativefire configure --auto-detect") + "                    # Full auto mode\n" +
                "  " + ui.Code("nativefire configure --project my-app --auto-detect") + "  # Auto-detect platform only\n" +
                "  " + ui.Code("nativefire configure --project my-app --platform ios") + "  # Explicit platform\n\n" +
                ui.Bold.Sprint("Platform-Specific Options:") + "\n" +
                "  " + ui.Code("--bundle-id") + "     - iOS/macOS Bundle Identifier\n" +
                "  " + ui.Code("--package-name") + "  - Android Package Name\n" +
                "  " + ui.Code("--app-id") + "        - Use existing Firebase App ID\n\n" +
                ui.Dim.Sprint("Pro tip: Use") + " " + ui.Code("--verbose") + " " + ui.Dim.Sprint("to see detailed progress."),
        RunE: runConfigure,
}

func init() <span class="cov1" title="1">{
        rootCmd.AddCommand(configureCmd)

        configureCmd.Flags().StringVarP(&amp;projectID, "project", "p", "", "Firebase project ID (will prompt if not provided)")
        configureCmd.Flags().StringVar(&amp;platformFlag, "platform", "", "Target platform (android, ios, macos, windows, linux)")
        configureCmd.Flags().BoolVar(&amp;autoDetect, "auto-detect", false, "Automatically detect the platform")
        configureCmd.Flags().StringVar(&amp;appID, "app-id", "", "Firebase app ID (optional, will generate if not provided)")
        configureCmd.Flags().StringVar(&amp;bundleID, "bundle-id", "",
                "iOS Bundle ID (will auto-detect or generate if not provided)")
        configureCmd.Flags().StringVar(&amp;packageName, "package-name", "",
                "Android Package Name (will auto-detect or generate if not provided)")

        // Make project optional - we'll prompt if not provided
}</span>

func runConfigure(cmd *cobra.Command, args []string) error <span class="cov10" title="3">{
        verbose := viper.GetBool("verbose")

        firebaseClient := firebase.NewClient(verbose)

        // If project ID not provided, prompt user to select
        if projectID == "" </span><span class="cov1" title="1">{
                selectedProjectID, err := promptProjectSelection(firebaseClient, verbose)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">projectID = selectedProjectID</span>
        }

        // Validate project exists and user has access
        <span class="cov6" title="2">if verbose </span><span class="cov0" title="0">{
                ui.InfoMsg(fmt.Sprintf("Validating Firebase project: %s", projectID))
        }</span>

        <span class="cov6" title="2">if err := firebaseClient.ValidateProject(projectID); err != nil </span><span class="cov6" title="2">{
                return fmt.Errorf("project validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                ui.SuccessMsg("Project validation successful")
        }</span>

        <span class="cov0" title="0">ui.ProjectHeader(projectID)

        var targetPlatform platform.Platform
        var err error

        switch </span>{
        case autoDetect:<span class="cov0" title="0">
                ui.Step(1, "Auto-detecting platform...")
                targetPlatform, err = platform.DetectPlatform()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to detect platform: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("   %s %s\n\n", ui.Check.Sprint("üéØ Detected platform:"), ui.Platform(targetPlatform.Name()))</span>
        case platformFlag != "":<span class="cov0" title="0">
                targetPlatform, err = platform.FromString(platformFlag)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid platform: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s %s\n\n", ui.Check.Sprint("üéØ Using platform:"), ui.Platform(targetPlatform.Name()))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("either --platform or --auto-detect flag must be specified")</span>
        }

        <span class="cov0" title="0">config := &amp;firebase.Config{
                ProjectID:   projectID,
                AppID:       appID,
                Platform:    targetPlatform,
                BundleID:    bundleID,
                PackageName: packageName,
        }

        ui.Step(2, "Registering app with Firebase...")
        err = firebaseClient.RegisterApp(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register app with Firebase: %w", err)
        }</span>

        <span class="cov0" title="0">ui.Step(3, "Downloading configuration file...")
        err = firebaseClient.DownloadConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download configuration: %w", err)
        }</span>

        <span class="cov0" title="0">ui.Step(4, "Installing configuration file...")
        err = targetPlatform.InstallConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install configuration: %w", err)
        }</span>

        <span class="cov0" title="0">ui.Step(5, "Adding Firebase initialization code...")
        err = targetPlatform.AddInitializationCode(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add initialization code: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nüéâ %s %s!\n",
                ui.Success.Sprint("Firebase configuration completed successfully for"),
                ui.Platform(targetPlatform.Name()))
        return nil</span>
}

func promptProjectSelection(firebaseClient *firebase.Client, verbose bool) (string, error) <span class="cov1" title="1">{
        // In test environments, return an error instead of prompting for input
        if isTestEnvironment() </span><span class="cov1" title="1">{
                return "", fmt.Errorf("project ID is required in test environment")
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                ui.InfoMsg("No project specified. Fetching available Firebase projects...")
        }</span>

        <span class="cov0" title="0">projects, err := firebaseClient.ListProjects()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to fetch projects for selection: %w", err)
        }</span>

        <span class="cov0" title="0">if len(projects) == 0 </span><span class="cov0" title="0">{
                ui.WarningMsg("No Firebase projects found")
                fmt.Printf("%s Create your first project at %s\n",
                        ui.Fire.Sprint("üîó"),
                        ui.Secondary.Sprint("https://console.firebase.google.com/"))
                return "", fmt.Errorf("no Firebase projects available")
        }</span>

        // If only one project, use it automatically
        <span class="cov0" title="0">if len(projects) == 1 </span><span class="cov0" title="0">{
                fmt.Printf("%s %s (%s)\n",
                        ui.Info.Sprint("üí° Found 1 Firebase project:"),
                        ui.Bold.Sprint(projects[0].DisplayName),
                        ui.Secondary.Sprint(projects[0].ProjectID))
                fmt.Printf("%s %s\n\n",
                        ui.Success.Sprint("üéØ Auto-selecting project:"),
                        ui.Secondary.Sprint(projects[0].ProjectID))
                return projects[0].ProjectID, nil
        }</span>

        // Multiple projects - show selection menu
        <span class="cov0" title="0">ui.Header("Select Firebase Project")
        fmt.Printf("Found %s project(s). Choose one:\n\n", ui.Success.Sprint(fmt.Sprintf("%d", len(projects))))

        for i, project := range projects </span><span class="cov0" title="0">{
                fmt.Printf("  %s %s\n",
                        ui.Primary.Sprint(fmt.Sprintf("[%d]", i+1)),
                        ui.Bold.Sprint(project.DisplayName))
                fmt.Printf("      %s %s\n",
                        ui.Dim.Sprint("ID:"),
                        ui.Secondary.Sprint(project.ProjectID))
                fmt.Println()
        }</span>

        // Get user selection
        <span class="cov0" title="0">fmt.Printf("%s ", ui.Primary.Sprint(fmt.Sprintf("Select a project (1-%d):", len(projects))))
        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read input: %w", err)
        }</span>

        <span class="cov0" title="0">input = strings.TrimSpace(input)
        selection, err := strconv.Atoi(input)
        if err != nil </span><span class="cov0" title="0">{
                ui.ErrorMsg(fmt.Sprintf("Invalid selection '%s'. Please enter a number between 1 and %d", input, len(projects)))
                return "", fmt.Errorf("invalid selection '%s'", input)
        }</span>

        <span class="cov0" title="0">if selection &lt; 1 || selection &gt; len(projects) </span><span class="cov0" title="0">{
                ui.ErrorMsg(fmt.Sprintf("Selection %d is out of range. Please enter a number between 1 and %d",
                        selection, len(projects)))
                return "", fmt.Errorf("selection %d is out of range", selection)
        }</span>

        <span class="cov0" title="0">selectedProject := projects[selection-1]
        fmt.Printf("\n%s %s (%s)\n\n",
                ui.Success.Sprint("‚úÖ Selected project:"),
                ui.Bold.Sprint(selectedProject.DisplayName),
                ui.Secondary.Sprint(selectedProject.ProjectID))

        return selectedProject.ProjectID, nil</span>
}

// isTestEnvironment checks if we're running in a test environment
func isTestEnvironment() bool <span class="cov1" title="1">{
        // Check if we're running under go test
        for _, arg := range os.Args </span><span class="cov1" title="1">{
                if strings.Contains(arg, "test") || strings.HasSuffix(arg, ".test") </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        // Check for test-specific environment variables
        <span class="cov0" title="0">if os.Getenv("GO_TEST") == "1" || os.Getenv("TESTING") == "1" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/clix-so/nativefire/internal/firebase"
        "github.com/clix-so/nativefire/internal/ui"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var projectsCmd = &amp;cobra.Command{
        Use:   "projects",
        Short: "üî• Manage Firebase projects",
        Long: ui.Primary.Sprint("üî• Firebase Project Management\n\n") +
                "Discover and manage your Firebase projects with ease.\n\n" +
                ui.Bold.Sprint("Available Commands:") + "\n" +
                "  ‚Ä¢ " + ui.Code("list") + "   - Show all your Firebase projects\n" +
                "  ‚Ä¢ " + ui.Code("select") + " - Pick a project interactively\n\n" +
                ui.Dim.Sprint("Pro tip: Use") + " " + ui.Code("--verbose") + " " + ui.Dim.Sprint("for detailed output."),
}

var projectsListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "üìã List all available Firebase projects",
        Long: ui.Info.Sprint("üìã Firebase Projects Overview\n\n") +
                "View all Firebase projects you have access to in a clean, organized format.\n\n" +
                ui.Bold.Sprint("Features:") + "\n" +
                "  ‚Ä¢ Clean, colorful project listing\n" +
                "  ‚Ä¢ Project IDs and display names\n" +
                "  ‚Ä¢ Quick copy-paste ready format\n" +
                "  ‚Ä¢ Usage examples included\n\n" +
                ui.Dim.Sprint("Example:") + " " + ui.Code("nativefire projects list"),
        RunE: runProjectsList,
}

var projectsSelectCmd = &amp;cobra.Command{
        Use:   "select",
        Short: "üéØ Interactively select a Firebase project",
        Long: ui.Success.Sprint("üéØ Interactive Project Selection\n\n") +
                "Choose your Firebase project from a beautiful, interactive list.\n\n" +
                ui.Bold.Sprint("Features:") + "\n" +
                "  ‚Ä¢ Interactive project picker\n" +
                "  ‚Ä¢ Real-time project information\n" +
                "  ‚Ä¢ Automatic configuration guidance\n" +
                "  ‚Ä¢ Optional Firebase CLI integration\n\n" +
                ui.Bold.Sprint("Flags:") + "\n" +
                "  " + ui.Code("--use") + " - Set selected project as Firebase CLI default\n\n" +
                ui.Dim.Sprint("Example:") + " " + ui.Code("nativefire projects select --use"),
        RunE: runProjectsSelect,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(projectsCmd)
        projectsCmd.AddCommand(projectsListCmd)
        projectsCmd.AddCommand(projectsSelectCmd)

        projectsSelectCmd.Flags().BoolVar(&amp;autoUse, "use", false, "Automatically use the selected project for configuration")
}</span>

var autoUse bool

func runProjectsList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        verbose := viper.GetBool("verbose")
        firebaseClient := firebase.NewClient(verbose)

        if verbose </span><span class="cov0" title="0">{
                ui.InfoMsg("Fetching Firebase projects...")
        }</span>

        <span class="cov0" title="0">projects, err := firebaseClient.ListProjects()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list projects: %w", err)
        }</span>

        <span class="cov0" title="0">if len(projects) == 0 </span><span class="cov0" title="0">{
                ui.WarningMsg("No Firebase projects found")
                fmt.Printf("\n%s Create your first project at %s\n",
                        ui.Fire.Sprint("üîó"),
                        ui.Secondary.Sprint("https://console.firebase.google.com/"))
                return nil
        }</span>

        // Beautiful header
        <span class="cov0" title="0">ui.Header("Your Firebase Projects")
        fmt.Printf("Found %s project(s)\n\n", ui.Success.Sprint(fmt.Sprintf("%d", len(projects))))

        // Display projects in a clean, modern format
        for i, project := range projects </span><span class="cov0" title="0">{
                // Project number with fire emoji
                fmt.Printf("%s %s\n",
                        ui.Fire.Sprint(fmt.Sprintf("%d.", i+1)),
                        ui.Bold.Sprint(project.DisplayName))

                // Project ID with subtle styling
                fmt.Printf("   %s %s\n",
                        ui.Dim.Sprint("ID:"),
                        ui.Secondary.Sprint(project.ProjectID))

                // Project number in verbose mode
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("   %s %s\n",
                                ui.Dim.Sprint("Number:"),
                                ui.Dim.Sprint(project.ProjectNumber))
                }</span>

                <span class="cov0" title="0">fmt.Println()</span> // Empty line between projects
        }

        // Usage instructions
        <span class="cov0" title="0">fmt.Printf("%s\n", ui.Bold.Sprint("Quick Start:"))
        fmt.Printf("  %s\n", ui.Code("nativefire configure --project &lt;PROJECT_ID&gt; --auto-detect"))
        fmt.Printf("  %s\n", ui.Code("nativefire projects select"))

        fmt.Printf("\n%s Copy any Project ID above and use it with the configure command.\n",
                ui.Info.Sprint("üí°"))

        return nil</span>
}

func runProjectsSelect(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        verbose := viper.GetBool("verbose")
        firebaseClient := firebase.NewClient(verbose)

        if verbose </span><span class="cov0" title="0">{
                ui.InfoMsg("Fetching Firebase projects...")
        }</span>

        <span class="cov0" title="0">projects, err := firebaseClient.ListProjects()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list projects: %w", err)
        }</span>

        <span class="cov0" title="0">if len(projects) == 0 </span><span class="cov0" title="0">{
                ui.WarningMsg("No Firebase projects found")
                fmt.Printf("\n%s Create your first project at %s\n",
                        ui.Fire.Sprint("üîó"),
                        ui.Secondary.Sprint("https://console.firebase.google.com/"))
                return nil
        }</span>

        // Beautiful header for selection
        <span class="cov0" title="0">ui.Header("Select Your Firebase Project")
        fmt.Printf("Choose from %s available project(s):\n\n", ui.Success.Sprint(fmt.Sprintf("%d", len(projects))))

        // Display projects with beautiful formatting
        for i, project := range projects </span><span class="cov0" title="0">{
                fmt.Printf("  %s %s\n",
                        ui.Primary.Sprint(fmt.Sprintf("[%d]", i+1)),
                        ui.Bold.Sprint(project.DisplayName))
                fmt.Printf("      %s %s\n",
                        ui.Dim.Sprint("ID:"),
                        ui.Secondary.Sprint(project.ProjectID))
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("      %s %s\n",
                                ui.Dim.Sprint("Number:"),
                                ui.Dim.Sprint(project.ProjectNumber))
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Get user selection with styled prompt
        <span class="cov0" title="0">fmt.Printf("%s ", ui.Primary.Sprint(fmt.Sprintf("Select a project (1-%d):", len(projects))))
        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read input: %w", err)
        }</span>

        <span class="cov0" title="0">input = strings.TrimSpace(input)
        selection, err := strconv.Atoi(input)
        if err != nil </span><span class="cov0" title="0">{
                ui.ErrorMsg(fmt.Sprintf("Invalid selection: %s", input))
                return fmt.Errorf("invalid selection: %s", input)
        }</span>

        <span class="cov0" title="0">if selection &lt; 1 || selection &gt; len(projects) </span><span class="cov0" title="0">{
                ui.ErrorMsg(fmt.Sprintf("Selection out of range: %d (valid: 1-%d)", selection, len(projects)))
                return fmt.Errorf("selection out of range: %d (valid range: 1-%d)", selection, len(projects))
        }</span>

        <span class="cov0" title="0">selectedProject := projects[selection-1]

        // Success message with project info
        fmt.Printf("\n%s %s\n",
                ui.Check.Sprint("üéâ Project Selected:"),
                ui.Bold.Sprint(selectedProject.DisplayName))
        fmt.Printf("   %s %s\n\n",
                ui.Dim.Sprint("Project ID:"),
                ui.Success.Sprint(selectedProject.ProjectID))

        if autoUse </span><span class="cov0" title="0">{
                ui.InfoMsg("Setting as default project for Firebase CLI...")
                fmt.Printf("%s %s\n",
                        ui.Dim.Sprint("Command:"),
                        ui.Code(fmt.Sprintf("firebase use %s", selectedProject.ProjectID)))
        }</span>

        // Next steps
        <span class="cov0" title="0">fmt.Printf("%s\n", ui.Bold.Sprint("Next Steps:"))
        fmt.Printf("  %s %s\n",
                ui.Rocket.Sprint("üöÄ"),
                ui.Code(fmt.Sprintf("nativefire configure --project %s --auto-detect", selectedProject.ProjectID)))

        fmt.Printf("\n%s Project ID ready to use: %s\n",
                ui.Info.Sprint("üí°"),
                ui.Secondary.Sprint(selectedProject.ProjectID))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/clix-so/nativefire/internal/ui"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var cfgFile string
var verbose bool

var rootCmd = &amp;cobra.Command{
        Use:   "nativefire",
        Short: "üî• Simplify Firebase setup in native development environments",
        Long: color.New(color.FgHiBlue).Sprint(`
üî• NativeFire - Firebase Setup Made Easy

NativeFire automatically detects your native development environment and sets up 
Firebase configuration for multiple platforms. Think of it as flutterfire for native apps!

`) + color.New(color.FgHiGreen).Sprint("Supported Platforms:") + `
  üì± iOS       ü§ñ Android     üñ•Ô∏è  macOS
  ü™ü Windows   üêß Linux       üåê Web

` + color.New(color.FgHiYellow).Sprint("Quick Start:") + `
  ` + ui.Code("nativefire configure --auto-detect") + `          # Let nativefire do everything
  ` + ui.Code("nativefire projects list") + `                   # See your Firebase projects  
  ` + ui.Code("nativefire projects select") + `                 # Pick a project interactively

` + color.New(color.FgHiCyan).Sprint("Advanced Usage:") + `
  ` + ui.Code("nativefire configure --project my-app --platform ios") + `
  ` + ui.Code("nativefire configure --bundle-id com.example.app") + `
  ` + ui.Code("nativefire configure --package-name com.example.app") + `

Need help? Use ` + ui.Code("nativefire [command] --help") + ` for detailed information.`,
}

func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov1" title="1">{
        cobra.OnInitialize(initConfig)

        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.nativefire.yaml)")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "verbose output")

        _ = viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose"))
}</span>

func initConfig() <span class="cov10" title="5">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov10" title="5"> {
                home, err := os.UserHomeDir()
                cobra.CheckErr(err)

                viper.AddConfigPath(home)
                viper.SetConfigType("yaml")
                viper.SetConfigName(".nativefire")
        }</span>

        <span class="cov10" title="5">viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err == nil &amp;&amp; verbose </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
)

var Version = "1.0.0"

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number of nativefire",
        Long:  `Print the version number of nativefire`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
                cmd.Printf("nativefire v%s\n", Version)
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package firebase

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/clix-so/nativefire/internal/ui"
)

// Constants for repeated strings
const (
        androidPlatform = "android"
        iosPlatform     = "ios"
        macosPlatform   = "macos"
        successStatus   = "success"
        activeState     = "ACTIVE"
)

type Config struct {
        ProjectID   string
        AppID       string
        Platform    PlatformInterface
        BundleID    string // For iOS/macOS apps
        PackageName string // For Android apps
        ConfigFile  string // Path to downloaded config file
}

type PlatformInterface interface {
        Name() string
        ConfigFileName() string
        ConfigPath() string
}

type Client struct {
        verbose bool
}

type App struct {
        AppID       string `json:"appId"`
        DisplayName string `json:"displayName"`
        ProjectID   string `json:"projectId"`
        Platform    string `json:"platform"`
        BundleID    string `json:"bundleId,omitempty"`
        PackageName string `json:"packageName,omitempty"`
        Namespace   string `json:"namespace,omitempty"` // Firebase uses 'namespace' for both bundle ID and package name
}

type Project struct {
        ProjectID     string         `json:"projectId"`
        ProjectNumber string         `json:"projectNumber"`
        DisplayName   string         `json:"displayName"`
        Name          string         `json:"name"`
        Resources     map[string]any `json:"resources"`
        State         string         `json:"state"`
        Etag          string         `json:"etag"`
}

type ProjectsListResponse struct {
        Status string    `json:"status"`
        Result []Project `json:"result"`
}

type AppsListResponse struct {
        Status string `json:"status"`
        Result []App  `json:"result"`
}

func NewClient(verbose bool) *Client <span class="cov9" title="15">{
        return &amp;Client{
                verbose: verbose,
        }
}</span>

func (c *Client) checkFirebaseCLI() error <span class="cov5" title="5">{
        _, err := exec.LookPath("firebase")
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("firebase CLI not found. Please install it first: npm install -g firebase-tools")
        }</span>
        <span class="cov5" title="4">return nil</span>
}

func (c *Client) checkAuthentication() error <span class="cov4" title="3">{
        cmd := exec.Command("firebase", "projects:list")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(string(output), "not authenticated") </span><span class="cov0" title="0">{
                        return fmt.Errorf("not authenticated with Firebase. Please run: firebase login")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to check authentication: %w", err)</span>
        }
        <span class="cov4" title="3">return nil</span>
}

func (c *Client) RegisterApp(config *Config) error <span class="cov1" title="1">{
        if err := c.checkFirebaseCLI(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if err := c.checkAuthentication(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if config.AppID != "" </span><span class="cov1" title="1">{
                if c.verbose </span><span class="cov1" title="1">{
                        ui.InfoMsg(fmt.Sprintf("Using existing app ID: %s", config.AppID))
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        // Check if an existing app matches our bundle ID/package name
        <span class="cov0" title="0">existingApp, err := c.FindExistingApp(config)
        if err != nil </span><span class="cov0" title="0">{
                if c.verbose </span><span class="cov0" title="0">{
                        ui.WarningMsg(fmt.Sprintf("Could not check for existing apps: %v", err))
                }</span>
        } else<span class="cov0" title="0"> if existingApp != nil </span><span class="cov0" title="0">{
                config.AppID = existingApp.AppID
                ui.SuccessMsg(fmt.Sprintf("Using existing %s app: %s (%s)",
                        existingApp.Platform,
                        existingApp.DisplayName,
                        existingApp.AppID))
                if c.verbose </span><span class="cov0" title="0">{
                        ui.InfoMsg("Skipping app creation - existing app found and configured")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">platformFlag := c.getPlatformFlag(config.Platform.Name())
        appName := c.generateAppName(config.Platform.Name())

        // Build the command with platform-specific identifiers
        cmd := c.buildCreateAppCommand(platformFlag, appName, config)

        if c.verbose </span><span class="cov0" title="0">{
                fmt.Printf("%s %s\n", ui.Dim.Sprint("Running:"), ui.Code(c.formatCommand(cmd.Args)))
        }</span>

        <span class="cov0" title="0">output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return c.handleAppCreationError(config, string(output))
        }</span>

        <span class="cov0" title="0">appID := c.extractAppIDFromOutput(string(output))
        if appID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract app ID from Firebase CLI output")
        }</span>

        <span class="cov0" title="0">config.AppID = appID

        if c.verbose </span><span class="cov0" title="0">{
                ui.SuccessMsg(fmt.Sprintf("Created Firebase app with ID: %s", appID))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DownloadConfig(config *Config) error <span class="cov3" title="2">{
        if config.AppID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("app ID is required to download configuration")
        }</span>

        // Generate a unique temp file path without creating the file
        // Let Firebase CLI create the file to avoid permission conflicts
        <span class="cov1" title="1">configExt := filepath.Ext(config.Platform.ConfigFileName())
        configBase := strings.TrimSuffix(config.Platform.ConfigFileName(), configExt)

        // Create a temporary file just to get a unique name, then remove it
        tempFile, err := os.CreateTemp("", fmt.Sprintf("nativefire_%s_*%s", configBase, configExt))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate temp filename: %w", err)
        }</span>
        <span class="cov1" title="1">configFile := tempFile.Name()
        tempFile.Close()
        os.Remove(configFile) // Remove the file so Firebase CLI can create it fresh

        // Store the temp file path in config for platform implementations to use
        config.ConfigFile = configFile

        var cmd *exec.Cmd
        platformName := strings.ToLower(config.Platform.Name())

        switch platformName </span>{
        case androidPlatform:<span class="cov0" title="0">
                cmd = exec.Command("firebase", "apps:sdkconfig", androidPlatform, config.AppID,
                        "--project", config.ProjectID, "--out", configFile)</span>
        case iosPlatform, macosPlatform:<span class="cov0" title="0">
                cmd = exec.Command("firebase", "apps:sdkconfig", iosPlatform, config.AppID,
                        "--project", config.ProjectID, "--out", configFile)</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("platform %s does not support automatic config download", platformName)</span>
        }

        <span class="cov0" title="0">if c.verbose </span><span class="cov0" title="0">{
                fmt.Printf("%s %s\n", ui.Dim.Sprint("Running:"), ui.Code(c.formatCommand(cmd.Args)))
        }</span>

        <span class="cov0" title="0">output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                // Clean up temp file if download fails
                os.Remove(configFile)
                return fmt.Errorf("failed to download config: %s", string(output))
        }</span>

        <span class="cov0" title="0">if c.verbose </span><span class="cov0" title="0">{
                ui.SuccessMsg(fmt.Sprintf("Configuration downloaded to: %s", configFile))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) getPlatformFlag(platformName string) string <span class="cov7" title="8">{
        switch strings.ToLower(platformName) </span>{
        case androidPlatform:<span class="cov3" title="2">
                return androidPlatform</span>
        case iosPlatform, macosPlatform:<span class="cov5" title="4">
                return iosPlatform</span>
        case "web":<span class="cov1" title="1">
                return "web"</span>
        default:<span class="cov1" title="1">
                return androidPlatform</span>
        }
}

func (c *Client) generateAppName(platformName string) string <span class="cov3" title="2">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("My %s App", platformName)
        }</span>

        <span class="cov3" title="2">projectName := filepath.Base(cwd)
        // Use safer format without parentheses to avoid shell interpretation issues
        return fmt.Sprintf("%s %s", projectName, platformName)</span>
}

func (c *Client) extractAppIDFromOutput(output string) string <span class="cov5" title="4">{
        // Try to match "App ID: [app-id]" format
        appIDRegex := regexp.MustCompile(`App ID:\s+([^\s\n]+)`)
        if matches := appIDRegex.FindStringSubmatch(output); len(matches) &gt; 1 </span><span class="cov1" title="1">{
                return matches[1]
        }</span>

        // Try to match JSON format: "appId": "app-id"
        <span class="cov4" title="3">jsonRegex := regexp.MustCompile(`"appId":\s*"([^"]+)"`)
        if matches := jsonRegex.FindStringSubmatch(output); len(matches) &gt; 1 </span><span class="cov3" title="2">{
                return matches[1]
        }</span>

        <span class="cov1" title="1">return ""</span>
}

func (c *Client) buildCreateAppCommand(platformFlag, appName string, config *Config) *exec.Cmd <span class="cov0" title="0">{
        args := []string{"apps:create", platformFlag, appName, "--project", config.ProjectID}

        // Add platform-specific identifiers
        switch strings.ToLower(config.Platform.Name()) </span>{
        case androidPlatform:<span class="cov0" title="0">
                packageName := config.PackageName
                if packageName == "" </span><span class="cov0" title="0">{
                        packageName = c.detectAndroidPackageName()
                }</span>
                <span class="cov0" title="0">if packageName == "" </span><span class="cov0" title="0">{
                        // Use a default package name based on project
                        packageName = c.generateDefaultPackageName(config.ProjectID)
                }</span>
                <span class="cov0" title="0">args = append(args, "--package-name", packageName)
                if c.verbose </span><span class="cov0" title="0">{
                        ui.InfoMsg(fmt.Sprintf("Using Android package name: %s", packageName))
                }</span>
        case iosPlatform, macosPlatform:<span class="cov0" title="0">
                bundleID := config.BundleID
                if bundleID == "" </span><span class="cov0" title="0">{
                        bundleID = c.detectIOSBundleID()
                }</span>
                <span class="cov0" title="0">if bundleID == "" </span><span class="cov0" title="0">{
                        // Use a default bundle ID based on project
                        bundleID = c.generateDefaultBundleID(config.ProjectID)
                }</span>
                <span class="cov0" title="0">args = append(args, "--bundle-id", bundleID)
                if c.verbose </span><span class="cov0" title="0">{
                        ui.InfoMsg(fmt.Sprintf("Using iOS bundle ID: %s", bundleID))
                }</span>
        }

        <span class="cov0" title="0">return exec.Command("firebase", args...)</span>
}

func (c *Client) detectAndroidPackageName() string <span class="cov0" title="0">{
        // Try to find package name in build.gradle files
        buildGradleFiles := []string{
                "app/build.gradle",
                "android/app/build.gradle",
                "build.gradle",
        }

        for _, file := range buildGradleFiles </span><span class="cov0" title="0">{
                if packageName := c.extractPackageNameFromBuildGradle(file); packageName != "" </span><span class="cov0" title="0">{
                        return packageName
                }</span>
        }

        // Try to find package name in AndroidManifest.xml
        <span class="cov0" title="0">manifestFiles := []string{
                "app/src/main/AndroidManifest.xml",
                "android/app/src/main/AndroidManifest.xml",
                "src/main/AndroidManifest.xml",
        }

        for _, file := range manifestFiles </span><span class="cov0" title="0">{
                if packageName := c.extractPackageNameFromManifest(file); packageName != "" </span><span class="cov0" title="0">{
                        return packageName
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (c *Client) detectIOSBundleID() string <span class="cov0" title="0">{
        // Try to find bundle ID in Info.plist files
        infoPlistFiles := []string{
                "ios/Runner/Info.plist",
                "Info.plist",
                "Runner/Info.plist",
        }

        for _, file := range infoPlistFiles </span><span class="cov0" title="0">{
                if bundleID := c.extractBundleIDFromInfoPlist(file); bundleID != "" </span><span class="cov0" title="0">{
                        return bundleID
                }</span>
        }

        // Try to find in project.pbxproj files
        <span class="cov0" title="0">pbxprojFiles, _ := filepath.Glob("*.xcodeproj/project.pbxproj")
        for _, file := range pbxprojFiles </span><span class="cov0" title="0">{
                if bundleID := c.extractBundleIDFromPbxproj(file); bundleID != "" </span><span class="cov0" title="0">{
                        return bundleID
                }</span>
        }

        // Try iOS subdirectory
        <span class="cov0" title="0">iosPbxprojFiles, _ := filepath.Glob("ios/*.xcodeproj/project.pbxproj")
        for _, file := range iosPbxprojFiles </span><span class="cov0" title="0">{
                if bundleID := c.extractBundleIDFromPbxproj(file); bundleID != "" </span><span class="cov0" title="0">{
                        return bundleID
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (c *Client) extractPackageNameFromBuildGradle(filename string) string <span class="cov0" title="0">{
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Look for applicationId in build.gradle
        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if strings.Contains(line, "applicationId") </span><span class="cov0" title="0">{
                        // Extract applicationId "com.example.app"
                        if idx := strings.Index(line, "\""); idx != -1 </span><span class="cov0" title="0">{
                                remaining := line[idx+1:]
                                if idx2 := strings.Index(remaining, "\""); idx2 != -1 </span><span class="cov0" title="0">{
                                        return remaining[:idx2]
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (c *Client) extractPackageNameFromManifest(filename string) string <span class="cov0" title="0">{
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Look for package attribute in AndroidManifest.xml
        <span class="cov0" title="0">contentStr := string(content)
        if idx := strings.Index(contentStr, "package=\""); idx != -1 </span><span class="cov0" title="0">{
                start := idx + len("package=\"")
                if end := strings.Index(contentStr[start:], "\""); end != -1 </span><span class="cov0" title="0">{
                        return contentStr[start : start+end]
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (c *Client) extractBundleIDFromInfoPlist(filename string) string <span class="cov0" title="0">{
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Look for CFBundleIdentifier in Info.plist
        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "CFBundleIdentifier") &amp;&amp; i+1 &lt; len(lines) </span><span class="cov0" title="0">{
                        nextLine := strings.TrimSpace(lines[i+1])
                        // Extract from &lt;string&gt;com.example.app&lt;/string&gt;
                        if strings.HasPrefix(nextLine, "&lt;string&gt;") &amp;&amp; strings.HasSuffix(nextLine, "&lt;/string&gt;") </span><span class="cov0" title="0">{
                                bundleID := nextLine[8 : len(nextLine)-9] // Remove &lt;string&gt; and &lt;/string&gt;
                                if bundleID != "$(PRODUCT_BUNDLE_IDENTIFIER)" </span><span class="cov0" title="0">{
                                        return bundleID
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (c *Client) extractBundleIDFromPbxproj(filename string) string <span class="cov0" title="0">{
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Look for PRODUCT_BUNDLE_IDENTIFIER in project.pbxproj
        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if strings.Contains(line, "PRODUCT_BUNDLE_IDENTIFIER") </span><span class="cov0" title="0">{
                        // Extract PRODUCT_BUNDLE_IDENTIFIER = com.example.app;
                        if idx := strings.Index(line, "="); idx != -1 </span><span class="cov0" title="0">{
                                remaining := strings.TrimSpace(line[idx+1:])
                                remaining = strings.TrimSuffix(remaining, ";")
                                remaining = strings.Trim(remaining, "\"")
                                if remaining != "" &amp;&amp; !strings.Contains(remaining, "$") </span><span class="cov0" title="0">{
                                        return remaining
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (c *Client) generateDefaultPackageName(projectID string) string <span class="cov4" title="3">{
        // Generate a valid Android package name from project ID
        // Replace hyphens with dots and ensure it starts with a domain-like structure
        sanitized := strings.ReplaceAll(projectID, "-", ".")
        if !strings.Contains(sanitized, ".") </span><span class="cov1" title="1">{
                return fmt.Sprintf("com.firebase.%s", sanitized)
        }</span>
        <span class="cov3" title="2">return fmt.Sprintf("com.%s", sanitized)</span>
}

func (c *Client) generateDefaultBundleID(projectID string) string <span class="cov4" title="3">{
        // Generate a valid iOS bundle ID from project ID
        // Replace hyphens with dots and ensure it starts with a domain-like structure
        sanitized := strings.ReplaceAll(projectID, "-", ".")
        if !strings.Contains(sanitized, ".") </span><span class="cov1" title="1">{
                return fmt.Sprintf("com.firebase.%s", sanitized)
        }</span>
        <span class="cov3" title="2">return fmt.Sprintf("com.%s", sanitized)</span>
}

func (c *Client) ListProjects() ([]Project, error) <span class="cov3" title="2">{
        if err := c.checkFirebaseCLI(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">if err := c.checkAuthentication(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="2">cmd := exec.Command("firebase", "projects:list", "--json")

        if c.verbose </span><span class="cov0" title="0">{
                fmt.Printf("%s %s\n", ui.Dim.Sprint("Running:"), ui.Code(c.formatCommand(cmd.Args)))
        }</span>

        <span class="cov3" title="2">output, err := cmd.Output() // Only capture stdout, ignore stderr
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list Firebase projects: %w", err)
        }</span>

        <span class="cov3" title="2">var response ProjectsListResponse
        if err := json.Unmarshal(output, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse projects response: %w", err)
        }</span>

        <span class="cov3" title="2">if response.Status != successStatus </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Firebase CLI returned non-success status: %s", response.Status)
        }</span>

        // Filter only active projects
        <span class="cov3" title="2">var activeProjects []Project
        for _, project := range response.Result </span><span class="cov9" title="14">{
                if project.State == activeState </span><span class="cov9" title="14">{
                        activeProjects = append(activeProjects, project)
                }</span>
        }

        <span class="cov3" title="2">return activeProjects, nil</span>
}

func (c *Client) ValidateProject(projectID string) error <span class="cov3" title="2">{
        projects, err := c.ListProjects()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate project: %w", err)
        }</span>

        <span class="cov3" title="2">for _, project := range projects </span><span class="cov9" title="14">{
                if project.ProjectID == projectID </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov3" title="2">return fmt.Errorf("project '%s' not found or you don't have access to it", projectID)</span>
}

func (c *Client) ListApps(projectID string) ([]App, error) <span class="cov0" title="0">{
        if err := c.checkFirebaseCLI(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := c.checkAuthentication(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("firebase", "apps:list", "--json", "--project", projectID)

        if c.verbose </span><span class="cov0" title="0">{
                fmt.Printf("%s %s\n", ui.Dim.Sprint("Running:"), ui.Code(c.formatCommand(cmd.Args)))
        }</span>

        <span class="cov0" title="0">output, err := cmd.Output() // Only capture stdout, ignore stderr
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list Firebase apps: %w", err)
        }</span>

        <span class="cov0" title="0">var response AppsListResponse
        if err := json.Unmarshal(output, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse apps response: %w", err)
        }</span>

        <span class="cov0" title="0">if response.Status != successStatus </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Firebase CLI returned non-success status: %s", response.Status)
        }</span>

        <span class="cov0" title="0">return response.Result, nil</span>
}

func (c *Client) FindExistingApp(config *Config) (*App, error) <span class="cov0" title="0">{
        apps, err := c.ListApps(config.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list apps: %w", err)
        }</span>

        <span class="cov0" title="0">platformName := strings.ToLower(config.Platform.Name())

        // Search through apps for matching platform and identifier
        for _, app := range apps </span><span class="cov0" title="0">{
                if strings.ToLower(app.Platform) != platformName </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if match := c.checkAppMatch(app, config, platformName); match </span><span class="cov0" title="0">{
                        return &amp;app, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span> // No existing app found
}

// checkAppMatch checks if an app matches the expected identifier for a platform
func (c *Client) checkAppMatch(app App, config *Config, platformName string) bool <span class="cov0" title="0">{
        if platformName == iosPlatform || platformName == macosPlatform </span><span class="cov0" title="0">{
                return c.checkIOSAppMatch(app, config)
        }</span>

        <span class="cov0" title="0">if platformName == androidPlatform </span><span class="cov0" title="0">{
                return c.checkAndroidAppMatch(app, config)
        }</span>

        <span class="cov0" title="0">return false</span>
}

// checkIOSAppMatch checks if an iOS/macOS app matches the expected bundle ID
func (c *Client) checkIOSAppMatch(app App, config *Config) bool <span class="cov0" title="0">{
        expectedBundleID := config.BundleID
        if expectedBundleID == "" </span><span class="cov0" title="0">{
                expectedBundleID = c.detectIOSBundleID()
        }</span>
        <span class="cov0" title="0">if expectedBundleID == "" </span><span class="cov0" title="0">{
                expectedBundleID = c.generateDefaultBundleID(config.ProjectID)
        }</span>

        // Check both bundleId field and namespace field
        <span class="cov0" title="0">bundleIDToCheck := app.BundleID
        if bundleIDToCheck == "" </span><span class="cov0" title="0">{
                bundleIDToCheck = app.Namespace
        }</span>

        <span class="cov0" title="0">if bundleIDToCheck == expectedBundleID </span><span class="cov0" title="0">{
                if c.verbose </span><span class="cov0" title="0">{
                        ui.InfoMsg(fmt.Sprintf("Found existing %s app with Bundle ID: %s", app.Platform, bundleIDToCheck))
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">return false</span>
}

// checkAndroidAppMatch checks if an Android app matches the expected package name
func (c *Client) checkAndroidAppMatch(app App, config *Config) bool <span class="cov0" title="0">{
        expectedPackageName := config.PackageName
        if expectedPackageName == "" </span><span class="cov0" title="0">{
                expectedPackageName = c.detectAndroidPackageName()
        }</span>
        <span class="cov0" title="0">if expectedPackageName == "" </span><span class="cov0" title="0">{
                expectedPackageName = c.generateDefaultPackageName(config.ProjectID)
        }</span>

        // Check both packageName field and namespace field
        <span class="cov0" title="0">packageNameToCheck := app.PackageName
        if packageNameToCheck == "" </span><span class="cov0" title="0">{
                packageNameToCheck = app.Namespace
        }</span>

        <span class="cov0" title="0">if packageNameToCheck == expectedPackageName </span><span class="cov0" title="0">{
                if c.verbose </span><span class="cov0" title="0">{
                        ui.InfoMsg(fmt.Sprintf("Found existing %s app with Package Name: %s", app.Platform, packageNameToCheck))
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">return false</span>
}

// formatCommand properly quotes command arguments that contain spaces or special characters
func (c *Client) formatCommand(args []string) string <span class="cov4" title="3">{
        quotedArgs := make([]string, len(args))
        for i, arg := range args </span><span class="cov7" title="8">{
                if strings.ContainsAny(arg, " \t\n()[]{}") </span><span class="cov3" title="2">{
                        quotedArgs[i] = fmt.Sprintf(`"%s"`, arg)
                }</span> else<span class="cov6" title="6"> {
                        quotedArgs[i] = arg
                }</span>
        }
        <span class="cov4" title="3">return strings.Join(quotedArgs, " ")</span>
}

// isDuplicateAppError checks if the Firebase CLI error indicates a duplicate app
func (c *Client) isDuplicateAppError(output string) bool <span class="cov6" title="6">{
        // Common indicators of duplicate app errors
        errorIndicators := []string{
                "already exists",
                "duplicate",
                "bundle id already exists",
                "package name already exists",
                "Bundle ID for iOS app cannot be empty", // Sometimes this indicates bundle ID conflict
                "Failed to create iOS app",
                "Failed to create Android app",
        }

        outputLower := strings.ToLower(output)
        for _, indicator := range errorIndicators </span><span class="cov10" title="19">{
                if strings.Contains(outputLower, strings.ToLower(indicator)) </span><span class="cov5" title="4">{
                        return true
                }</span>
        }

        <span class="cov3" title="2">return false</span>
}

// findExistingAppByIdentifier performs a more thorough search for existing apps
// resolveExpectedIdentifier gets the expected identifier for the platform
func (c *Client) resolveExpectedIdentifier(config *Config, platformName string) string <span class="cov0" title="0">{
        if platformName == iosPlatform || platformName == macosPlatform </span><span class="cov0" title="0">{
                expectedIdentifier := config.BundleID
                if expectedIdentifier == "" </span><span class="cov0" title="0">{
                        expectedIdentifier = c.detectIOSBundleID()
                }</span>
                <span class="cov0" title="0">if expectedIdentifier == "" </span><span class="cov0" title="0">{
                        expectedIdentifier = c.generateDefaultBundleID(config.ProjectID)
                }</span>
                <span class="cov0" title="0">return expectedIdentifier</span>
        }

        <span class="cov0" title="0">if platformName == androidPlatform </span><span class="cov0" title="0">{
                expectedIdentifier := config.PackageName
                if expectedIdentifier == "" </span><span class="cov0" title="0">{
                        expectedIdentifier = c.detectAndroidPackageName()
                }</span>
                <span class="cov0" title="0">if expectedIdentifier == "" </span><span class="cov0" title="0">{
                        expectedIdentifier = c.generateDefaultPackageName(config.ProjectID)
                }</span>
                <span class="cov0" title="0">return expectedIdentifier</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// filterAppsByPlatform filters apps by platform name
func (c *Client) filterAppsByPlatform(apps []App, platformName string) []App <span class="cov4" title="3">{
        var platformApps []App
        for _, app := range apps </span><span class="cov8" title="12">{
                if strings.ToLower(app.Platform) == platformName </span><span class="cov5" title="4">{
                        platformApps = append(platformApps, app)
                }</span>
        }
        <span class="cov4" title="3">return platformApps</span>
}

// logPlatformApps logs platform apps for debugging
func (c *Client) logPlatformApps(platformApps []App, platformName string) <span class="cov0" title="0">{
        ui.InfoMsg(fmt.Sprintf("Found %d %s apps in project:", len(platformApps), platformName))
        for i, app := range platformApps </span><span class="cov0" title="0">{
                ui.InfoMsg(fmt.Sprintf("  %d. %s (namespace: %s, bundleId: %s, packageName: %s)",
                        i+1, app.DisplayName, app.Namespace, app.BundleID, app.PackageName))
        }</span>
        <span class="cov0" title="0">ui.InfoMsg("Searching for exact matches only...")</span>
}

// findMatchingApp searches for an app matching the expected identifier
func (c *Client) findMatchingApp(platformApps []App, expectedIdentifier, platformName string) *App <span class="cov0" title="0">{
        for _, app := range platformApps </span><span class="cov0" title="0">{
                // Check the namespace field (which contains bundle ID or package name)
                if app.Namespace == expectedIdentifier </span><span class="cov0" title="0">{
                        if c.verbose </span><span class="cov0" title="0">{
                                ui.InfoMsg(fmt.Sprintf("Found exact match by namespace: %s", app.Namespace))
                        }</span>
                        <span class="cov0" title="0">return &amp;app</span>
                }

                // Also check the specific fields as fallback
                <span class="cov0" title="0">if platformName == iosPlatform || platformName == macosPlatform </span><span class="cov0" title="0">{
                        if app.BundleID == expectedIdentifier </span><span class="cov0" title="0">{
                                if c.verbose </span><span class="cov0" title="0">{
                                        ui.InfoMsg(fmt.Sprintf("Found exact match by bundle ID: %s", app.BundleID))
                                }</span>
                                <span class="cov0" title="0">return &amp;app</span>
                        }
                } else<span class="cov0" title="0"> if platformName == androidPlatform </span><span class="cov0" title="0">{
                        if app.PackageName == expectedIdentifier </span><span class="cov0" title="0">{
                                if c.verbose </span><span class="cov0" title="0">{
                                        ui.InfoMsg(fmt.Sprintf("Found exact match by package name: %s", app.PackageName))
                                }</span>
                                <span class="cov0" title="0">return &amp;app</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// handleAppCreationError handles errors during app creation
func (c *Client) handleAppCreationError(config *Config, outputStr string) error <span class="cov0" title="0">{
        // Check if this is a duplicate app error
        if c.isDuplicateAppError(outputStr) </span><span class="cov0" title="0">{
                if c.verbose </span><span class="cov0" title="0">{
                        ui.WarningMsg("App creation failed, searching for existing app...")
                }</span>

                // Try to find the existing app again with a more thorough search
                <span class="cov0" title="0">existingApp, findErr := c.findExistingAppByIdentifier(config)
                if findErr == nil &amp;&amp; existingApp != nil </span><span class="cov0" title="0">{
                        config.AppID = existingApp.AppID
                        ui.SuccessMsg(fmt.Sprintf("Found and using existing %s app: %s (%s)",
                                existingApp.Platform,
                                existingApp.DisplayName,
                                existingApp.AppID))
                        return nil
                }</span>

                // If we still can't find an existing app, provide helpful guidance
                <span class="cov0" title="0">if c.verbose </span><span class="cov0" title="0">{
                        ui.WarningMsg("Could not find existing app to use as fallback")
                        c.suggestManualCreation(config)
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to create Firebase app: %s", outputStr)</span>
}

func (c *Client) findExistingAppByIdentifier(config *Config) (*App, error) <span class="cov0" title="0">{
        apps, err := c.ListApps(config.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">platformName := strings.ToLower(config.Platform.Name())

        // Get the expected identifier (bundle ID or package name)
        expectedIdentifier := c.resolveExpectedIdentifier(config, platformName)

        if c.verbose </span><span class="cov0" title="0">{
                ui.InfoMsg(fmt.Sprintf("Searching for existing %s app with identifier: %s", platformName, expectedIdentifier))
                ui.InfoMsg(fmt.Sprintf("Found %d total apps in project", len(apps)))
        }</span>

        // First, list all apps of the target platform for debugging
        <span class="cov0" title="0">platformApps := c.filterAppsByPlatform(apps, platformName)

        if c.verbose </span><span class="cov0" title="0">{
                c.logPlatformApps(platformApps, platformName)
        }</span>

        // Search through all apps for matching platform and identifier
        <span class="cov0" title="0">matchedApp := c.findMatchingApp(platformApps, expectedIdentifier, platformName)
        if matchedApp != nil </span><span class="cov0" title="0">{
                return matchedApp, nil
        }</span>

        <span class="cov0" title="0">if c.verbose </span><span class="cov0" title="0">{
                ui.WarningMsg(fmt.Sprintf("No existing %s app found with identifier: %s", platformName, expectedIdentifier))
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// suggestManualCreation provides helpful guidance when automatic app creation fails
func (c *Client) suggestManualCreation(config *Config) <span class="cov0" title="0">{
        platformName := strings.ToLower(config.Platform.Name())

        ui.InfoMsg("Manual creation options:")

        if platformName == iosPlatform || platformName == macosPlatform </span><span class="cov0" title="0">{
                expectedBundleID := config.BundleID
                if expectedBundleID == "" </span><span class="cov0" title="0">{
                        expectedBundleID = c.detectIOSBundleID()
                }</span>
                <span class="cov0" title="0">if expectedBundleID == "" </span><span class="cov0" title="0">{
                        expectedBundleID = c.generateDefaultBundleID(config.ProjectID)
                }</span>

                <span class="cov0" title="0">fmt.Printf("  1. Create an app manually in Firebase Console with Bundle ID: %s\n",
                        ui.Secondary.Sprint(expectedBundleID))
                fmt.Printf("  2. Or run: %s\n",
                        ui.Code(fmt.Sprintf("firebase apps:create ios \"My App\" --project %s --bundle-id %s",
                                config.ProjectID, expectedBundleID)))</span>
        } else<span class="cov0" title="0"> if platformName == androidPlatform </span><span class="cov0" title="0">{
                expectedPackageName := config.PackageName
                if expectedPackageName == "" </span><span class="cov0" title="0">{
                        expectedPackageName = c.detectAndroidPackageName()
                }</span>
                <span class="cov0" title="0">if expectedPackageName == "" </span><span class="cov0" title="0">{
                        expectedPackageName = c.generateDefaultPackageName(config.ProjectID)
                }</span>

                <span class="cov0" title="0">fmt.Printf("  1. Create an app manually in Firebase Console with Package Name: %s\n",
                        ui.Secondary.Sprint(expectedPackageName))
                fmt.Printf("  2. Or run: %s\n",
                        ui.Code(fmt.Sprintf("firebase apps:create android \"My App\" --project %s --package-name %s",
                                config.ProjectID, expectedPackageName)))</span>
        }

        <span class="cov0" title="0">fmt.Printf("  3. Then use the app ID with: %s\n",
                ui.Code(fmt.Sprintf("nativefire configure --project %s --app-id YOUR_APP_ID", config.ProjectID)))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "fmt"
        "os"
)

type Logger struct {
        verbose bool
}

func New(verbose bool) *Logger <span class="cov0" title="0">{
        return &amp;Logger{verbose: verbose}
}</span>

func (l *Logger) Info(msg string) <span class="cov0" title="0">{
        fmt.Println(msg)
}</span>

func (l *Logger) Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Printf(format+"\n", args...)
}</span>

func (l *Logger) Debug(msg string) <span class="cov0" title="0">{
        if l.verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] %s\n", msg)
        }</span>
}

func (l *Logger) Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        if l.verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] "+format+"\n", args...)
        }</span>
}

func (l *Logger) Warn(msg string) <span class="cov0" title="0">{
        fmt.Printf("‚ö†Ô∏è  %s\n", msg)
}</span>

func (l *Logger) Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("‚ö†Ô∏è  "+format+"\n", args...)
}</span>

func (l *Logger) Error(msg string) <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, "‚ùå %s\n", msg)
}</span>

func (l *Logger) Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, "‚ùå "+format+"\n", args...)
}</span>

func (l *Logger) Success(msg string) <span class="cov0" title="0">{
        fmt.Printf("‚úÖ %s\n", msg)
}</span>

func (l *Logger) Successf(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Printf("‚úÖ "+format+"\n", args...)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package platform

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/clix-so/nativefire/internal/firebase"
        "github.com/clix-so/nativefire/internal/ui"
)

// Constants for repeated strings
const (
        googleServicesJSON = "google-services.json"
        appDir             = "app"
)

func (p *AndroidPlatform) Name() string <span class="cov1" title="1">{
        return "Android"
}</span>

func (p *AndroidPlatform) Type() Type <span class="cov7" title="6">{
        return Android
}</span>

func (p *AndroidPlatform) Detect() bool <span class="cov10" title="11">{
        return fileExists("build.gradle") ||
                fileExists("app/build.gradle") ||
                fileExists("android/build.gradle") ||
                fileExists("settings.gradle")
}</span>

func (p *AndroidPlatform) ConfigFileName() string <span class="cov8" title="7">{
        return googleServicesJSON
}</span>

func (p *AndroidPlatform) ConfigPath() string <span class="cov6" title="4">{
        if fileExists("app/src/main") </span><span class="cov3" title="2">{
                return appDir
        }</span>
        <span class="cov3" title="2">if fileExists("android/app/src/main") </span><span class="cov1" title="1">{
                return "android/app"
        }</span>
        <span class="cov1" title="1">return appDir</span>
}

func (p *AndroidPlatform) InstallConfig(config *firebase.Config) error <span class="cov5" title="3">{
        configPath := p.ConfigPath()
        targetPath := filepath.Join(configPath, p.ConfigFileName())

        if err := os.MkdirAll(configPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", configPath, err)
        }</span>

        // Use the unique temp file path from config instead of hardcoded temp location
        <span class="cov5" title="3">sourceFile := config.ConfigFile
        if sourceFile == "" </span><span class="cov5" title="3">{
                // Fallback to old behavior if ConfigFile is not set
                sourceFile = filepath.Join(os.TempDir(), p.ConfigFileName())
        }</span>

        <span class="cov5" title="3">sourceData, err := os.ReadFile(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source config file: %w", err)
        }</span>

        <span class="cov5" title="3">if err := os.WriteFile(targetPath, sourceData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file to %s: %w", targetPath, err)
        }</span>

        // Clean up the temp file after successful installation
        <span class="cov5" title="3">if config.ConfigFile != "" </span><span class="cov0" title="0">{
                os.Remove(config.ConfigFile)
        }</span>

        <span class="cov5" title="3">ui.SuccessMsg(fmt.Sprintf("Configuration file installed at: %s", targetPath))
        return nil</span>
}

func (p *AndroidPlatform) AddInitializationCode(config *firebase.Config) error <span class="cov3" title="2">{
        buildGradlePath := p.findBuildGradle()
        if buildGradlePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find app-level build.gradle file")
        }</span>

        <span class="cov3" title="2">content, err := os.ReadFile(buildGradlePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read build.gradle: %w", err)
        }</span>

        <span class="cov3" title="2">contentStr := string(content)
        gradleModified := false

        if !strings.Contains(contentStr, "google-services") </span><span class="cov3" title="2">{
                if strings.Contains(contentStr, "plugins {") </span><span class="cov1" title="1">{
                        contentStr = strings.Replace(contentStr,
                                "plugins {",
                                "plugins {\n    id 'com.google.gms.google-services'", 1)
                }</span> else<span class="cov1" title="1"> {
                        contentStr = "apply plugin: 'com.google.gms.google-services'\n\n" + contentStr
                }</span>

                <span class="cov3" title="2">if err := os.WriteFile(buildGradlePath, []byte(contentStr), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update build.gradle: %w", err)
                }</span>
                <span class="cov3" title="2">ui.SuccessMsg(fmt.Sprintf("Added Google Services plugin to: %s", buildGradlePath))
                gradleModified = true</span>
        }

        <span class="cov3" title="2">projectBuildGradlePath := p.findProjectBuildGradle()
        if projectBuildGradlePath != "" </span><span class="cov0" title="0">{
                if err := p.addClasspathToBuildGradle(projectBuildGradlePath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">gradleModified = true</span>
        }

        <span class="cov3" title="2">if err := p.addFirebaseImportsToMainActivity(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Run Gradle sync after modifications
        <span class="cov3" title="2">if gradleModified </span><span class="cov3" title="2">{
                return p.runGradleSync()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *AndroidPlatform) findBuildGradle() string <span class="cov7" title="6">{
        candidates := []string{
                "app/build.gradle",
                "android/app/build.gradle",
                "build.gradle",
        }

        for _, candidate := range candidates </span><span class="cov10" title="11">{
                if fileExists(candidate) </span><span class="cov7" title="5">{
                        return candidate
                }</span>
        }
        <span class="cov1" title="1">return ""</span>
}

func (p *AndroidPlatform) findProjectBuildGradle() string <span class="cov3" title="2">{
        candidates := []string{
                "build.gradle",
                "android/build.gradle",
        }

        for _, candidate := range candidates </span><span class="cov6" title="4">{
                if fileExists(candidate) </span><span class="cov0" title="0">{
                        content, err := os.ReadFile(candidate)
                        if err == nil &amp;&amp; strings.Contains(string(content), "buildscript") </span><span class="cov0" title="0">{
                                return candidate
                        }</span>
                }
        }
        <span class="cov3" title="2">return ""</span>
}

func (p *AndroidPlatform) addClasspathToBuildGradle(buildGradlePath string) error <span class="cov0" title="0">{
        content, err := os.ReadFile(buildGradlePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read project build.gradle: %w", err)
        }</span>

        <span class="cov0" title="0">contentStr := string(content)

        if !strings.Contains(contentStr, "google-services") </span><span class="cov0" title="0">{
                if strings.Contains(contentStr, "dependencies {") </span><span class="cov0" title="0">{
                        insertPoint := strings.Index(contentStr, "dependencies {") + len("dependencies {")
                        newContent := contentStr[:insertPoint] +
                                "\n        classpath 'com.google.gms:google-services:4.3.15'" +
                                contentStr[insertPoint:]

                        if err := os.WriteFile(buildGradlePath, []byte(newContent), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update project build.gradle: %w", err)
                        }</span>
                        <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Added Google Services classpath to: %s", buildGradlePath))</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (p *AndroidPlatform) addFirebaseImportsToMainActivity() error <span class="cov3" title="2">{
        mainActivityPath := findFile(".", "MainActivity.java")
        if mainActivityPath == "" </span><span class="cov3" title="2">{
                mainActivityPath = findFile(".", "MainActivity.kt")
        }</span>

        <span class="cov3" title="2">if mainActivityPath == "" </span><span class="cov3" title="2">{
                ui.WarningMsg("MainActivity not found. Please manually add Firebase initialization code")
                return nil
        }</span>

        <span class="cov0" title="0">content, err := os.ReadFile(mainActivityPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read MainActivity: %w", err)
        }</span>

        <span class="cov0" title="0">contentStr := string(content)

        if strings.Contains(mainActivityPath, ".java") </span><span class="cov0" title="0">{
                if !strings.Contains(contentStr, "FirebaseApp.initializeApp") </span><span class="cov0" title="0">{
                        contentStr = strings.Replace(contentStr,
                                "import",
                                "import com.google.firebase.FirebaseApp;\nimport", 1)

                        if strings.Contains(contentStr, "onCreate") </span><span class="cov0" title="0">{
                                contentStr = strings.Replace(contentStr,
                                        "super.onCreate(savedInstanceState);",
                                        "super.onCreate(savedInstanceState);\n        FirebaseApp.initializeApp(this);", 1)
                        }</span>
                }
        } else<span class="cov0" title="0"> if strings.Contains(mainActivityPath, ".kt") </span><span class="cov0" title="0">{
                if !strings.Contains(contentStr, "FirebaseApp.initializeApp") </span><span class="cov0" title="0">{
                        contentStr = strings.Replace(contentStr,
                                "import",
                                "import com.google.firebase.FirebaseApp\nimport", 1)

                        if strings.Contains(contentStr, "onCreate") </span><span class="cov0" title="0">{
                                contentStr = strings.Replace(contentStr,
                                        "super.onCreate(savedInstanceState)",
                                        "super.onCreate(savedInstanceState)\n        FirebaseApp.initializeApp(this)", 1)
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := os.WriteFile(mainActivityPath, []byte(contentStr), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update MainActivity: %w", err)
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Added Firebase initialization to: %s", mainActivityPath))
        return nil</span>
}

func (p *AndroidPlatform) runGradleSync() error <span class="cov3" title="2">{
        ui.InfoMsg("Running Gradle sync...")

        // Check for Gradle wrapper first
        if fileExists("gradlew") </span><span class="cov0" title="0">{
                return p.runGradlew()
        }</span>

        // Check for system Gradle
        <span class="cov3" title="2">if p.hasSystemGradle() </span><span class="cov0" title="0">{
                return p.runSystemGradle()
        }</span>

        <span class="cov3" title="2">ui.WarningMsg("Gradle not found. Please sync your project manually")
        ui.InfoMsg("In Android Studio: File &gt; Sync Project with Gradle Files")
        return nil</span>
}

func (p *AndroidPlatform) runGradlew() error <span class="cov0" title="0">{
        ui.InfoMsg("Using Gradle Wrapper...")

        // Run gradlew sync or build to trigger dependency resolution
        if err := p.runCommand("./gradlew", []string{"--refresh-dependencies"}, "Syncing Gradle dependencies"); err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg("Gradle sync failed. Please sync manually in Android Studio")
                ui.InfoMsg("In Android Studio: File &gt; Sync Project with Gradle Files")
                return nil
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg("Gradle dependencies synced successfully!")
        return nil</span>
}

func (p *AndroidPlatform) hasSystemGradle() bool <span class="cov3" title="2">{
        cmd := exec.Command("which", "gradle")
        return cmd.Run() == nil
}</span>

func (p *AndroidPlatform) runSystemGradle() error <span class="cov0" title="0">{
        ui.InfoMsg("Using system Gradle...")

        if err := p.runCommand("gradle", []string{"--refresh-dependencies"}, "Syncing Gradle dependencies"); err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg("Gradle sync failed. Please sync manually in Android Studio")
                ui.InfoMsg("In Android Studio: File &gt; Sync Project with Gradle Files")
                return nil
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg("Gradle dependencies synced successfully!")
        return nil</span>
}

func (p *AndroidPlatform) runCommand(command string, args []string, description string) error <span class="cov0" title="0">{
        ui.InfoMsg(fmt.Sprintf("Running: %s %s", command, strings.Join(args, " ")))

        cmd := exec.Command(command, args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg(fmt.Sprintf("Command failed: %s", string(output)))
                return err
        }</span>

        <span class="cov0" title="0">if len(output) &gt; 0 </span><span class="cov0" title="0">{
                ui.InfoMsg(string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package platform

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/clix-so/nativefire/internal/firebase"
)

// Constants for repeated strings
const (
        googleServiceInfoPlistDesktop = "GoogleService-Info.plist"
        googleServicesJSONDesktop     = "google-services.json"
)

func (p *MacOSPlatform) Name() string <span class="cov1" title="1">{
        return "macOS"
}</span>

func (p *MacOSPlatform) Type() Type <span class="cov8" title="4">{
        return MacOS
}</span>

func (p *MacOSPlatform) Detect() bool <span class="cov10" title="5">{
        return fileExists("macos") ||
                (findFile(".", "*.xcodeproj") != "" &amp;&amp; fileExists("Podfile")) ||
                findFile(".", "main.swift") != ""
}</span>

func (p *MacOSPlatform) ConfigFileName() string <span class="cov0" title="0">{
        return googleServiceInfoPlistDesktop
}</span>

func (p *MacOSPlatform) ConfigPath() string <span class="cov0" title="0">{
        if fileExists("macos") </span><span class="cov0" title="0">{
                return "macos"
        }</span>
        <span class="cov0" title="0">return "."</span>
}

func (p *MacOSPlatform) InstallConfig(config *firebase.Config) error <span class="cov0" title="0">{
        return p.installConfigHelper()
}</span>

func (p *MacOSPlatform) AddInitializationCode(config *firebase.Config) error <span class="cov0" title="0">{
        return p.addInitializationHelper()
}</span>

func (p *WindowsPlatform) Name() string <span class="cov1" title="1">{
        return "Windows"
}</span>

func (p *WindowsPlatform) Type() Type <span class="cov10" title="5">{
        return Windows
}</span>

func (p *WindowsPlatform) Detect() bool <span class="cov8" title="4">{
        return fileExists("windows") ||
                findFile(".", "*.vcxproj") != "" ||
                findFile(".", "*.sln") != "" ||
                fileExists("CMakeLists.txt")
}</span>

func (p *WindowsPlatform) ConfigFileName() string <span class="cov0" title="0">{
        return googleServicesJSONDesktop
}</span>

func (p *WindowsPlatform) ConfigPath() string <span class="cov0" title="0">{
        if fileExists("windows") </span><span class="cov0" title="0">{
                return "windows"
        }</span>
        <span class="cov0" title="0">return "."</span>
}

func (p *WindowsPlatform) InstallConfig(config *firebase.Config) error <span class="cov0" title="0">{
        return p.installConfigHelper()
}</span>

func (p *WindowsPlatform) AddInitializationCode(config *firebase.Config) error <span class="cov0" title="0">{
        return p.addInitializationHelper()
}</span>

func (p *LinuxPlatform) Name() string <span class="cov1" title="1">{
        return "Linux"
}</span>

func (p *LinuxPlatform) Type() Type <span class="cov8" title="4">{
        return Linux
}</span>

func (p *LinuxPlatform) Detect() bool <span class="cov4" title="2">{
        return fileExists("linux") ||
                fileExists("CMakeLists.txt") ||
                findFile(".", "Makefile") != ""
}</span>

func (p *LinuxPlatform) ConfigFileName() string <span class="cov0" title="0">{
        return googleServicesJSONDesktop
}</span>

func (p *LinuxPlatform) ConfigPath() string <span class="cov0" title="0">{
        if fileExists("linux") </span><span class="cov0" title="0">{
                return "linux"
        }</span>
        <span class="cov0" title="0">return "."</span>
}

func (p *LinuxPlatform) InstallConfig(config *firebase.Config) error <span class="cov0" title="0">{
        return p.installConfigHelper()
}</span>

func (p *LinuxPlatform) AddInitializationCode(config *firebase.Config) error <span class="cov0" title="0">{
        return p.addInitializationHelper()
}</span>

func (p *MacOSPlatform) installConfigHelper() error <span class="cov0" title="0">{
        configPath := p.ConfigPath()
        targetPath := filepath.Join(configPath, p.ConfigFileName())

        if err := os.MkdirAll(configPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", configPath, err)
        }</span>

        <span class="cov0" title="0">sourceFile := filepath.Join(os.TempDir(), p.ConfigFileName())

        sourceData, err := os.ReadFile(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source config file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(targetPath, sourceData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file to %s: %w", targetPath, err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Configuration file installed at: %s\n", targetPath)
        return nil</span>
}

func (p *MacOSPlatform) addInitializationHelper() error <span class="cov0" title="0">{
        fmt.Printf("‚ö†Ô∏è  Please manually add Firebase initialization code to your %s application.\n", p.Name())
        fmt.Println("üí° Refer to Firebase documentation for platform-specific initialization steps.")
        return nil
}</span>

func (p *WindowsPlatform) installConfigHelper() error <span class="cov0" title="0">{
        configPath := p.ConfigPath()
        targetPath := filepath.Join(configPath, p.ConfigFileName())

        if err := os.MkdirAll(configPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", configPath, err)
        }</span>

        <span class="cov0" title="0">sourceFile := filepath.Join(os.TempDir(), p.ConfigFileName())

        sourceData, err := os.ReadFile(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source config file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(targetPath, sourceData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file to %s: %w", targetPath, err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Configuration file installed at: %s\n", targetPath)
        return nil</span>
}

func (p *WindowsPlatform) addInitializationHelper() error <span class="cov0" title="0">{
        fmt.Printf("‚ö†Ô∏è  Please manually add Firebase initialization code to your %s application.\n", p.Name())
        fmt.Println("üí° Refer to Firebase documentation for platform-specific initialization steps.")
        return nil
}</span>

func (p *LinuxPlatform) installConfigHelper() error <span class="cov0" title="0">{
        configPath := p.ConfigPath()
        targetPath := filepath.Join(configPath, p.ConfigFileName())

        if err := os.MkdirAll(configPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", configPath, err)
        }</span>

        <span class="cov0" title="0">sourceFile := filepath.Join(os.TempDir(), p.ConfigFileName())

        sourceData, err := os.ReadFile(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source config file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(targetPath, sourceData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file to %s: %w", targetPath, err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Configuration file installed at: %s\n", targetPath)
        return nil</span>
}

func (p *LinuxPlatform) addInitializationHelper() error <span class="cov0" title="0">{
        fmt.Printf("‚ö†Ô∏è  Please manually add Firebase initialization code to your %s application.\n", p.Name())
        fmt.Println("üí° Refer to Firebase documentation for platform-specific initialization steps.")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package platform

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/clix-so/nativefire/internal/firebase"
        "github.com/clix-so/nativefire/internal/ui"
)

// Constants for repeated strings
const (
        googleServiceInfoPlist = "GoogleService-Info.plist"
)

func (p *IOSPlatform) Name() string <span class="cov3" title="2">{
        return "iOS"
}</span>

func (p *IOSPlatform) Type() Type <span class="cov8" title="6">{
        return iOS
}</span>

func (p *IOSPlatform) Detect() bool <span class="cov10" title="10">{
        return fileExists("ios") ||
                findFile(".", "*.xcodeproj") != "" ||
                findFile(".", "*.xcworkspace") != "" ||
                fileExists("Podfile")
}</span>

func (p *IOSPlatform) ConfigFileName() string <span class="cov3" title="2">{
        return googleServiceInfoPlist
}</span>

func (p *IOSPlatform) ConfigPath() string <span class="cov3" title="2">{
        if fileExists("ios") </span><span class="cov1" title="1">{
                return "ios"
        }</span>
        <span class="cov1" title="1">return "."</span>
}

func (p *IOSPlatform) InstallConfig(config *firebase.Config) error <span class="cov0" title="0">{
        configPath := p.ConfigPath()

        runnerPath := filepath.Join(configPath, "Runner")
        if fileExists(runnerPath) </span><span class="cov0" title="0">{
                configPath = runnerPath
        }</span>

        <span class="cov0" title="0">projectName := p.findProjectName()
        if projectName != "" </span><span class="cov0" title="0">{
                projectPath := filepath.Join(configPath, projectName)
                if fileExists(projectPath) </span><span class="cov0" title="0">{
                        configPath = projectPath
                }</span>
        }

        <span class="cov0" title="0">targetPath := filepath.Join(configPath, p.ConfigFileName())

        if err := os.MkdirAll(configPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", configPath, err)
        }</span>

        // Use the unique temp file path from config instead of hardcoded temp location
        <span class="cov0" title="0">sourceFile := config.ConfigFile
        if sourceFile == "" </span><span class="cov0" title="0">{
                // Fallback to old behavior if ConfigFile is not set
                sourceFile = filepath.Join(os.TempDir(), p.ConfigFileName())
        }</span>

        <span class="cov0" title="0">sourceData, err := os.ReadFile(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source config file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(targetPath, sourceData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file to %s: %w", targetPath, err)
        }</span>

        // Clean up the temp file after successful installation
        <span class="cov0" title="0">if config.ConfigFile != "" </span><span class="cov0" title="0">{
                os.Remove(config.ConfigFile)
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Configuration file installed at: %s", targetPath))
        ui.WarningMsg("Please add GoogleService-Info.plist to your Xcode project manually")
        return nil</span>
}

func (p *IOSPlatform) AddInitializationCode(config *firebase.Config) error <span class="cov0" title="0">{
        podfilePath := p.findPodfile()
        podsAdded := false

        if podfilePath != "" </span><span class="cov0" title="0">{
                if err := p.addFirebasePods(podfilePath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">podsAdded = true</span>
        }

        <span class="cov0" title="0">appDelegatePath := p.findAppDelegate()
        if appDelegatePath == "" </span><span class="cov0" title="0">{
                // AppDelegate not found, create one
                ui.InfoMsg("AppDelegate not found, creating one...")
                var err error
                appDelegatePath, err = p.createAppDelegate()
                if err != nil </span><span class="cov0" title="0">{
                        ui.WarningMsg(fmt.Sprintf("Failed to create AppDelegate: %v", err))
                        ui.WarningMsg("Please manually add Firebase initialization code")
                        return nil
                }</span>
                <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Created AppDelegate at: %s", appDelegatePath))</span>
        }

        <span class="cov0" title="0">if err := p.addFirebaseInitialization(appDelegatePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Run package manager commands after all changes
        <span class="cov0" title="0">if podsAdded </span><span class="cov0" title="0">{
                return p.runPackageManagerCommands()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *IOSPlatform) findProjectName() string <span class="cov7" title="5">{
        xcodeproj := findFile(".", "*.xcodeproj")
        if xcodeproj != "" </span><span class="cov3" title="2">{
                return strings.TrimSuffix(filepath.Base(xcodeproj), ".xcodeproj")
        }</span>
        <span class="cov5" title="3">return ""</span>
}

func (p *IOSPlatform) findPodfile() string <span class="cov6" title="4">{
        candidates := []string{
                "Podfile",
                "ios/Podfile",
        }

        for _, candidate := range candidates </span><span class="cov8" title="7">{
                if fileExists(candidate) </span><span class="cov3" title="2">{
                        return candidate
                }</span>
        }
        <span class="cov3" title="2">return ""</span>
}

func (p *IOSPlatform) findAppDelegate() string <span class="cov5" title="3">{
        appDelegatePath := findFile(".", "AppDelegate.swift")
        if appDelegatePath == "" </span><span class="cov3" title="2">{
                appDelegatePath = findFile(".", "AppDelegate.m")
        }</span>
        <span class="cov5" title="3">return appDelegatePath</span>
}

func (p *IOSPlatform) addFirebasePods(podfilePath string) error <span class="cov0" title="0">{
        content, err := os.ReadFile(podfilePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read Podfile: %w", err)
        }</span>

        <span class="cov0" title="0">contentStr := string(content)

        if !strings.Contains(contentStr, "Firebase/Core") </span><span class="cov0" title="0">{
                lines := strings.Split(contentStr, "\n")
                var newLines []string

                for _, line := range lines </span><span class="cov0" title="0">{
                        newLines = append(newLines, line)
                        if strings.Contains(line, "target") &amp;&amp; strings.Contains(line, "do") </span><span class="cov0" title="0">{
                                newLines = append(newLines, "  pod 'Firebase/Core'")
                                newLines = append(newLines, "  pod 'Firebase/Analytics'")
                        }</span>
                }

                <span class="cov0" title="0">newContent := strings.Join(newLines, "\n")
                if err := os.WriteFile(podfilePath, []byte(newContent), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update Podfile: %w", err)
                }</span>

                <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Added Firebase pods to: %s", podfilePath))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (p *IOSPlatform) checkFirebaseAppDelegateProxy() (bool, error) <span class="cov0" title="0">{
        // Check for FirebaseAppDelegateProxyEnabled in Info.plist files
        infoPlistFiles := []string{
                "ios/Runner/Info.plist",
                "Info.plist",
                "Runner/Info.plist",
        }

        for _, file := range infoPlistFiles </span><span class="cov0" title="0">{
                if !fileExists(file) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">content, err := os.ReadFile(file)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">contentStr := string(content)
                if strings.Contains(contentStr, "FirebaseAppDelegateProxyEnabled") </span><span class="cov0" title="0">{
                        // Look for the value after FirebaseAppDelegateProxyEnabled
                        lines := strings.Split(contentStr, "\n")
                        for i, line := range lines </span><span class="cov0" title="0">{
                                if strings.Contains(line, "FirebaseAppDelegateProxyEnabled") &amp;&amp; i+1 &lt; len(lines) </span><span class="cov0" title="0">{
                                        nextLine := strings.TrimSpace(lines[i+1])
                                        if strings.Contains(nextLine, "&lt;false/&gt;") || strings.Contains(nextLine, "&lt;false&gt;&lt;/false&gt;") </span><span class="cov0" title="0">{
                                                return false, nil // Proxy is disabled
                                        }</span>
                                }
                        }
                }
        }

        // Default is true (proxy enabled) if not specified
        <span class="cov0" title="0">return true, nil</span>
}

func (p *IOSPlatform) addFirebaseInitialization(appDelegatePath string) error <span class="cov0" title="0">{
        // Check if FirebaseAppDelegateProxyEnabled is disabled
        proxyEnabled, err := p.checkFirebaseAppDelegateProxy()
        if err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg("Could not check FirebaseAppDelegateProxyEnabled setting, proceeding with default configuration")
        }</span>

        <span class="cov0" title="0">content, err := os.ReadFile(appDelegatePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read AppDelegate: %w", err)
        }</span>

        <span class="cov0" title="0">contentStr := string(content)

        if strings.Contains(appDelegatePath, ".swift") </span><span class="cov0" title="0">{
                return p.addSwiftFirebaseInitialization(contentStr, appDelegatePath, proxyEnabled)
        }</span> else<span class="cov0" title="0"> if strings.Contains(appDelegatePath, ".m") </span><span class="cov0" title="0">{
                return p.addObjCFirebaseInitialization(contentStr, appDelegatePath, proxyEnabled)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("unsupported AppDelegate file type: %s", appDelegatePath)</span>
}

func (p *IOSPlatform) addSwiftFirebaseInitialization(contentStr, appDelegatePath string, proxyEnabled bool) error <span class="cov0" title="0">{
        // Check if Firebase is already configured
        if strings.Contains(contentStr, "FirebaseApp.configure()") </span><span class="cov0" title="0">{
                ui.InfoMsg("Firebase is already configured in AppDelegate")
                return nil
        }</span>

        // Add Firebase import
        <span class="cov0" title="0">if !strings.Contains(contentStr, "import Firebase") </span><span class="cov0" title="0">{
                if strings.Contains(contentStr, "import UIKit") </span><span class="cov0" title="0">{
                        contentStr = strings.Replace(contentStr,
                                "import UIKit",
                                "import UIKit\nimport Firebase", 1)
                }</span> else<span class="cov0" title="0"> {
                        // Add import at the beginning
                        contentStr = "import Firebase\n" + contentStr
                }</span>
        }

        // Add FirebaseApp.configure() in didFinishLaunchingWithOptions
        <span class="cov0" title="0">if strings.Contains(contentStr, "didFinishLaunchingWithOptions") </span><span class="cov0" title="0">{
                const swiftMethod = "func application(_ application: UIApplication, " +
                        "didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {"
                const swiftMethodWithFirebase = "func application(_ application: UIApplication, " +
                        "didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {" +
                        "\n        FirebaseApp.configure()"
                contentStr = strings.Replace(contentStr, swiftMethod, swiftMethodWithFirebase, 1)
        }</span>

        // If FirebaseAppDelegateProxyEnabled is disabled, add required delegate methods
        <span class="cov0" title="0">if !proxyEnabled </span><span class="cov0" title="0">{
                contentStr = p.addSwiftDelegateMethods(contentStr)
                ui.InfoMsg("Added Firebase delegate methods (FirebaseAppDelegateProxyEnabled is disabled)")
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(appDelegatePath, []byte(contentStr), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update AppDelegate: %w", err)
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Added Firebase initialization to: %s", appDelegatePath))
        if !proxyEnabled </span><span class="cov0" title="0">{
                ui.InfoMsg("Added additional delegate methods for manual Firebase integration")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *IOSPlatform) addObjCFirebaseInitialization(contentStr, appDelegatePath string, proxyEnabled bool) error <span class="cov0" title="0">{
        // Check if Firebase is already configured
        if strings.Contains(contentStr, "[FIRApp configure]") </span><span class="cov0" title="0">{
                ui.InfoMsg("Firebase is already configured in AppDelegate")
                return nil
        }</span>

        // Add Firebase import
        <span class="cov0" title="0">if !strings.Contains(contentStr, "@import Firebase;") &amp;&amp;
                !strings.Contains(contentStr, "#import &lt;Firebase/Firebase.h&gt;") </span><span class="cov0" title="0">{
                if strings.Contains(contentStr, "#import \"AppDelegate.h\"") </span><span class="cov0" title="0">{
                        contentStr = strings.Replace(contentStr,
                                "#import \"AppDelegate.h\"",
                                "#import \"AppDelegate.h\"\n@import Firebase;", 1)
                }</span> else<span class="cov0" title="0"> {
                        // Add import at the beginning
                        contentStr = "@import Firebase;\n" + contentStr
                }</span>
        }

        // Add [FIRApp configure]; in didFinishLaunchingWithOptions
        <span class="cov0" title="0">if strings.Contains(contentStr, "didFinishLaunchingWithOptions") </span><span class="cov0" title="0">{
                const objcMethod = "- (BOOL)application:(UIApplication *)application " +
                        "didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {"
                const objcMethodWithFirebase = "- (BOOL)application:(UIApplication *)application " +
                        "didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    [FIRApp configure];"
                contentStr = strings.Replace(contentStr, objcMethod, objcMethodWithFirebase, 1)
        }</span>

        // If FirebaseAppDelegateProxyEnabled is disabled, add required delegate methods
        <span class="cov0" title="0">if !proxyEnabled </span><span class="cov0" title="0">{
                contentStr = p.addObjCDelegateMethods(contentStr)
                ui.InfoMsg("Added Firebase delegate methods (FirebaseAppDelegateProxyEnabled is disabled)")
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(appDelegatePath, []byte(contentStr), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update AppDelegate: %w", err)
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Added Firebase initialization to: %s", appDelegatePath))
        if !proxyEnabled </span><span class="cov0" title="0">{
                ui.InfoMsg("Added additional delegate methods for manual Firebase integration")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *IOSPlatform) addSwiftDelegateMethods(contentStr string) string <span class="cov0" title="0">{
        // Add required delegate methods for push notifications when FirebaseAppDelegateProxyEnabled is NO
        delegateMethods := `
    // MARK: - Firebase Push Notification Delegate Methods
    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        Messaging.messaging().apnsToken = deviceToken
    }
    
    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        print("Failed to register for remote notifications: \(error)")
    }
    
    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any]) {
        // Handle background notification
    }
    
    func application(_ application: UIApplication, 
                     didReceiveRemoteNotification userInfo: [AnyHashable: Any], 
                     fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {
        // Handle background notification with completion handler
        completionHandler(.newData)
    }`

        // Add import for Firebase Messaging if not present
        if !strings.Contains(contentStr, "import FirebaseMessaging") </span><span class="cov0" title="0">{
                contentStr = strings.Replace(contentStr,
                        "import Firebase",
                        "import Firebase\nimport FirebaseMessaging", 1)
        }</span>

        // Find the end of the class and add delegate methods before the closing brace
        <span class="cov0" title="0">if strings.Contains(contentStr, "@UIApplicationMain") || strings.Contains(contentStr, "class AppDelegate") </span><span class="cov0" title="0">{
                // Find the last closing brace of the class
                lastBraceIndex := strings.LastIndex(contentStr, "}")
                if lastBraceIndex != -1 </span><span class="cov0" title="0">{
                        contentStr = contentStr[:lastBraceIndex] + delegateMethods + "\n" + contentStr[lastBraceIndex:]
                }</span>
        }

        <span class="cov0" title="0">return contentStr</span>
}

func (p *IOSPlatform) addObjCDelegateMethods(contentStr string) string <span class="cov0" title="0">{
        // Add required delegate methods for push notifications when FirebaseAppDelegateProxyEnabled is NO
        delegateMethods := `
#pragma mark - Firebase Push Notification Delegate Methods

- (void)application:(UIApplication *)application 
didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
    [FIRMessaging messaging].APNSToken = deviceToken;
}

- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {
    NSLog(@"Failed to register for remote notifications: %@", error);
}

- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {
    // Handle background notification
}

- (void)application:(UIApplication *)application
                     didReceiveRemoteNotification:(NSDictionary *)userInfo
                           fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
    // Handle background notification with completion handler
    completionHandler(UIBackgroundFetchResultNewData);
}`

        // Add import for Firebase Messaging if not present
        if !strings.Contains(contentStr, "@import FirebaseMessaging;") &amp;&amp;
                !strings.Contains(contentStr, "#import &lt;FirebaseMessaging/FirebaseMessaging.h&gt;") </span><span class="cov0" title="0">{
                contentStr = strings.Replace(contentStr,
                        "@import Firebase;",
                        "@import Firebase;\n@import FirebaseMessaging;", 1)
        }</span>

        // Find the end of the implementation and add delegate methods before @end
        <span class="cov0" title="0">if strings.Contains(contentStr, "@end") </span><span class="cov0" title="0">{
                endIndex := strings.LastIndex(contentStr, "@end")
                if endIndex != -1 </span><span class="cov0" title="0">{
                        contentStr = contentStr[:endIndex] + delegateMethods + "\n\n" + contentStr[endIndex:]
                }</span>
        }

        <span class="cov0" title="0">return contentStr</span>
}

func (p *IOSPlatform) createAppDelegate() (string, error) <span class="cov0" title="0">{
        // Determine project language and structure
        isSwift := p.isSwiftProject()
        projectPath := p.determineAppDelegatePath()

        if isSwift </span><span class="cov0" title="0">{
                // Check if this is a SwiftUI project
                if p.isSwiftUIProject() </span><span class="cov0" title="0">{
                        return p.createSwiftUIAppDelegateIntegration(projectPath)
                }</span> else<span class="cov0" title="0"> {
                        return p.createSwiftAppDelegate(projectPath)
                }</span>
        } else<span class="cov0" title="0"> {
                return p.createObjCAppDelegate(projectPath)
        }</span>
}

func (p *IOSPlatform) isSwiftProject() bool <span class="cov5" title="3">{
        // Check for existing Swift files
        if findFile(".", "*.swift") != "" </span><span class="cov1" title="1">{
                return true
        }</span>

        // Check for Objective-C files
        <span class="cov3" title="2">if findFile(".", "*.m") != "" || findFile(".", "*.h") != "" </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check Podfile for Swift usage
        <span class="cov1" title="1">podfilePath := p.findPodfile()
        if podfilePath != "" </span><span class="cov0" title="0">{
                content, err := os.ReadFile(podfilePath)
                if err == nil </span><span class="cov0" title="0">{
                        contentStr := string(content)
                        if strings.Contains(contentStr, "use_frameworks!") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        // Default to Swift for new projects
        <span class="cov1" title="1">return true</span>
}

func (p *IOSPlatform) determineAppDelegatePath() string <span class="cov5" title="3">{
        // Check for existing project structure
        projectName := p.findProjectName()

        // Try different common locations
        candidates := []string{
                "ios",
                ".",
        }

        if projectName != "" </span><span class="cov1" title="1">{
                candidates = append([]string{
                        filepath.Join("ios", projectName),
                        projectName,
                }, candidates...)
        }</span>

        // Use the first existing directory, or current directory as fallback
        <span class="cov5" title="3">for _, candidate := range candidates </span><span class="cov6" title="4">{
                if fileExists(candidate) </span><span class="cov5" title="3">{
                        return candidate
                }</span>
        }

        <span class="cov0" title="0">return "."</span>
}

func (p *IOSPlatform) createSwiftAppDelegate(projectPath string) (string, error) <span class="cov0" title="0">{
        appDelegatePath := filepath.Join(projectPath, "AppDelegate.swift")

        // Check if file already exists
        if fileExists(appDelegatePath) </span><span class="cov0" title="0">{
                return appDelegatePath, nil
        }</span>

        // Create directory if needed
        <span class="cov0" title="0">if err := os.MkdirAll(projectPath, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create directory %s: %w", projectPath, err)
        }</span>

        <span class="cov0" title="0">swiftContent := `import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    func application(_ application: UIApplication,
                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle (iOS 13+)
    @available(iOS 13.0, *)
    func application(_ application: UIApplication,
                     configurationForConnecting connectingSceneSession: UISceneSession,
                     options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration {
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    @available(iOS 13.0, *)
    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) {
        // Called when the user discards a scene session.
    }
}
`

        if err := os.WriteFile(appDelegatePath, []byte(swiftContent), 0644); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write AppDelegate.swift: %w", err)
        }</span>

        <span class="cov0" title="0">return appDelegatePath, nil</span>
}

func (p *IOSPlatform) createObjCAppDelegate(projectPath string) (string, error) <span class="cov0" title="0">{
        appDelegateHPath := filepath.Join(projectPath, "AppDelegate.h")
        appDelegateMPath := filepath.Join(projectPath, "AppDelegate.m")

        // Check if files already exist
        if fileExists(appDelegateMPath) </span><span class="cov0" title="0">{
                return appDelegateMPath, nil
        }</span>

        // Create directory if needed
        <span class="cov0" title="0">if err := os.MkdirAll(projectPath, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create directory %s: %w", projectPath, err)
        }</span>

        // Create AppDelegate.h
        <span class="cov0" title="0">headerContent := `#import &lt;UIKit/UIKit.h&gt;

@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;

@property (strong, nonatomic) UIWindow *window;

@end
`

        if err := os.WriteFile(appDelegateHPath, []byte(headerContent), 0644); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write AppDelegate.h: %w", err)
        }</span>

        // Create AppDelegate.m
        <span class="cov0" title="0">implementationContent := `#import "AppDelegate.h"

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    return YES;
}

#pragma mark - UISceneSession lifecycle (iOS 13+)

- (UISceneConfiguration *)application:(UIApplication *)application 
                 configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession 
                                                options:(UISceneConnectionOptions *)options API_AVAILABLE(ios(13.0)) {
    return [[UISceneConfiguration alloc] initWithName:@"Default Configuration" sessionRole:connectingSceneSession.role];
}

- (void)application:(UIApplication *)application 
    didDiscardSceneSessions:(NSSet&lt;UISceneSession *&gt; *)sceneSessions API_AVAILABLE(ios(13.0)) {
    // Called when the user discards a scene session.
}

@end
`

        if err := os.WriteFile(appDelegateMPath, []byte(implementationContent), 0644); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write AppDelegate.m: %w", err)
        }</span>

        <span class="cov0" title="0">return appDelegateMPath, nil</span>
}

func (p *IOSPlatform) isSwiftUIProject() bool <span class="cov0" title="0">{
        // Check for SwiftUI App files
        appFile := findFile(".", "*App.swift")
        if appFile != "" </span><span class="cov0" title="0">{
                content, err := os.ReadFile(appFile)
                if err == nil </span><span class="cov0" title="0">{
                        contentStr := string(content)
                        if strings.Contains(contentStr, "import SwiftUI") &amp;&amp; strings.Contains(contentStr, "@main") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        // Check for SwiftUI imports in any Swift files
        <span class="cov0" title="0">swiftFiles := []string{}
        err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if strings.HasSuffix(path, ".swift") </span><span class="cov0" title="0">{
                        swiftFiles = append(swiftFiles, path)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                for _, file := range swiftFiles </span><span class="cov0" title="0">{
                        content, err := os.ReadFile(file)
                        if err == nil </span><span class="cov0" title="0">{
                                contentStr := string(content)
                                if strings.Contains(contentStr, "import SwiftUI") </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false</span>
}

func (p *IOSPlatform) createSwiftUIAppDelegateIntegration(projectPath string) (string, error) <span class="cov0" title="0">{
        // First create the AppDelegate
        appDelegatePath := filepath.Join(projectPath, "AppDelegate.swift")

        // Check if AppDelegate already exists
        if fileExists(appDelegatePath) </span><span class="cov0" title="0">{
                return appDelegatePath, nil
        }</span>

        // Create directory if needed
        <span class="cov0" title="0">if err := os.MkdirAll(projectPath, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create directory %s: %w", projectPath, err)
        }</span>

        // Create AppDelegate for SwiftUI
        <span class="cov0" title="0">swiftUIAppDelegateContent := `import UIKit

class AppDelegate: NSObject, UIApplicationDelegate {
    
    func application(_ application: UIApplication,
                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        // Override point for customization after application launch.
        return true
    }
    
    // MARK: UISceneSession Lifecycle (iOS 13+)
    func application(_ application: UIApplication,
                     configurationForConnecting connectingSceneSession: UISceneSession,
                     options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration {
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }
    
    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) {
        // Called when the user discards a scene session.
    }
}
`

        if err := os.WriteFile(appDelegatePath, []byte(swiftUIAppDelegateContent), 0644); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write AppDelegate.swift: %w", err)
        }</span>

        // Now find or create the SwiftUI App file and add the delegate adaptor
        <span class="cov0" title="0">if err := p.addDelegateAdaptorToSwiftUIApp(projectPath); err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg(fmt.Sprintf("Created AppDelegate but failed to add delegate adaptor: %v", err))
                ui.InfoMsg("Please manually add '@UIApplicationDelegateAdaptor(AppDelegate.self) var delegate' to your SwiftUI App")
        }</span>

        <span class="cov0" title="0">return appDelegatePath, nil</span>
}

func (p *IOSPlatform) addDelegateAdaptorToSwiftUIApp(projectPath string) error <span class="cov0" title="0">{
        // Find existing SwiftUI App file
        appFile := findFile(".", "*App.swift")

        if appFile == "" </span><span class="cov0" title="0">{
                // Create a new SwiftUI App file
                return p.createSwiftUIAppFile(projectPath)
        }</span>

        // Add delegate adaptor to existing App file
        <span class="cov0" title="0">content, err := os.ReadFile(appFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read App file: %w", err)
        }</span>

        <span class="cov0" title="0">contentStr := string(content)

        // Check if delegate adaptor already exists
        if strings.Contains(contentStr, "@UIApplicationDelegateAdaptor") </span><span class="cov0" title="0">{
                ui.InfoMsg("UIApplicationDelegateAdaptor already exists in SwiftUI App")
                return nil
        }</span>

        // Add delegate adaptor after @main line
        <span class="cov0" title="0">if strings.Contains(contentStr, "@main") </span><span class="cov0" title="0">{
                // Find the struct declaration
                lines := strings.Split(contentStr, "\n")
                var newLines []string
                delegateAdded := false

                for i := 0; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                        line := lines[i]
                        newLines = append(newLines, line)

                        // Add delegate adaptor after struct declaration
                        if !delegateAdded &amp;&amp; strings.Contains(line, "struct") &amp;&amp; strings.Contains(line, "App") </span><span class="cov0" title="0">{
                                // Look for the opening brace
                                if strings.Contains(line, "{") </span><span class="cov0" title="0">{
                                        newLines = append(newLines, "    @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate")
                                        newLines = append(newLines, "")
                                        delegateAdded = true
                                }</span> else<span class="cov0" title="0"> if i+1 &lt; len(lines) &amp;&amp; strings.Contains(lines[i+1], "{") </span><span class="cov0" title="0">{
                                        // Opening brace is on next line
                                        i++ // Skip the next line since we're processing it here
                                        newLines = append(newLines, lines[i])
                                        newLines = append(newLines, "    @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate")
                                        newLines = append(newLines, "")
                                        delegateAdded = true
                                }</span>
                        }
                }

                <span class="cov0" title="0">if delegateAdded </span><span class="cov0" title="0">{
                        newContent := strings.Join(newLines, "\n")
                        if err := os.WriteFile(appFile, []byte(newContent), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update SwiftUI App file: %w", err)
                        }</span>
                        <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Added UIApplicationDelegateAdaptor to: %s", appFile))</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("could not find appropriate location to add delegate adaptor")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (p *IOSPlatform) createSwiftUIAppFile(projectPath string) error <span class="cov0" title="0">{
        projectName := p.findProjectName()
        if projectName == "" </span><span class="cov0" title="0">{
                projectName = "MyApp"
        }</span>

        <span class="cov0" title="0">appFileName := fmt.Sprintf("%sApp.swift", projectName)
        appFilePath := filepath.Join(projectPath, appFileName)

        // Check if file already exists
        if fileExists(appFilePath) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">swiftUIAppContent := fmt.Sprintf(`import SwiftUI

@main
struct %sApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
`, projectName)

        if err := os.WriteFile(appFilePath, []byte(swiftUIAppContent), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write SwiftUI App file: %w", err)
        }</span>

        // Also create a basic ContentView if it doesn't exist
        <span class="cov0" title="0">contentViewPath := filepath.Join(projectPath, "ContentView.swift")
        if !fileExists(contentViewPath) </span><span class="cov0" title="0">{
                contentViewContent := `import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            Image(systemName: "globe")
                .imageScale(.large)
                .foregroundColor(.accentColor)
            Text("Hello, world!")
        }
        .padding()
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
`
                _ = os.WriteFile(contentViewPath, []byte(contentViewContent), 0644)
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg(fmt.Sprintf("Created SwiftUI App file: %s", appFilePath))
        return nil</span>
}

func (p *IOSPlatform) runPackageManagerCommands() error <span class="cov0" title="0">{
        ui.InfoMsg("Running package manager commands...")

        // Check for CocoaPods
        if p.findPodfile() != "" </span><span class="cov0" title="0">{
                return p.runPodInstall()
        }</span>

        // Check for Swift Package Manager
        <span class="cov0" title="0">if p.hasSwiftPackages() </span><span class="cov0" title="0">{
                return p.updateSwiftPackages()
        }</span>

        <span class="cov0" title="0">ui.InfoMsg("No package manager detected")
        return nil</span>
}

func (p *IOSPlatform) runPodInstall() error <span class="cov0" title="0">{
        ui.InfoMsg("Installing CocoaPods dependencies...")

        // Check if pod command exists
        if err := p.checkPodCommand(); err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg("CocoaPods not found. Please install CocoaPods and run 'pod install' manually")
                ui.InfoMsg("Install CocoaPods: sudo gem install cocoapods")
                return nil
        }</span>

        // Run pod install
        <span class="cov0" title="0">if err := p.runCommand("pod", []string{"install"}, "Installing CocoaPods dependencies"); err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg("Failed to run 'pod install'. Please run it manually")
                ui.InfoMsg("Run: pod install")
                return nil
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg("CocoaPods dependencies installed successfully!")
        ui.InfoMsg("Make sure to open the .xcworkspace file in Xcode, not the .xcodeproj file")
        return nil</span>
}

func (p *IOSPlatform) hasSwiftPackages() bool <span class="cov5" title="3">{
        // Check for Package.swift or .swiftpm directory
        return fileExists("Package.swift") || fileExists(".swiftpm")
}</span>

func (p *IOSPlatform) updateSwiftPackages() error <span class="cov0" title="0">{
        ui.InfoMsg("Updating Swift Package dependencies...")

        // For SPM projects, we can try to resolve packages
        if err := p.runCommand("swift", []string{"package", "resolve"}, "Resolving Swift Package dependencies"); err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg("Failed to resolve Swift packages. Please update them manually in Xcode")
                ui.InfoMsg("In Xcode: File &gt; Package Dependencies &gt; Reset Package Caches")
                return nil
        }</span>

        <span class="cov0" title="0">ui.SuccessMsg("Swift Package dependencies resolved successfully!")
        return nil</span>
}

func (p *IOSPlatform) checkPodCommand() error <span class="cov0" title="0">{
        cmd := exec.Command("which", "pod")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("CocoaPods not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (p *IOSPlatform) runCommand(command string, args []string, description string) error <span class="cov0" title="0">{
        ui.InfoMsg(fmt.Sprintf("Running: %s %s", command, strings.Join(args, " ")))
        _ = description // Parameter kept for interface consistency

        cmd := exec.Command(command, args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                ui.WarningMsg(fmt.Sprintf("Command failed: %s", string(output)))
                return err
        }</span>

        <span class="cov0" title="0">if len(output) &gt; 0 </span><span class="cov0" title="0">{
                ui.InfoMsg(string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package platform

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/clix-so/nativefire/internal/firebase"
)

type Type int

const (
        Android Type = iota
        iOS
        MacOS
        Windows
        Linux
)

type Platform interface {
        Name() string
        Type() Type
        Detect() bool
        InstallConfig(config *firebase.Config) error
        AddInitializationCode(config *firebase.Config) error
        ConfigFileName() string
        ConfigPath() string
}

type AndroidPlatform struct{}
type IOSPlatform struct{}
type MacOSPlatform struct{}
type WindowsPlatform struct{}
type LinuxPlatform struct{}

func DetectPlatform() (Platform, error) <span class="cov5" title="10">{
        platforms := []Platform{
                &amp;AndroidPlatform{},
                &amp;IOSPlatform{},
                &amp;MacOSPlatform{},
                &amp;WindowsPlatform{},
                &amp;LinuxPlatform{},
        }

        for _, platform := range platforms </span><span class="cov7" title="28">{
                if platform.Detect() </span><span class="cov5" title="9">{
                        return platform, nil
                }</span>
        }

        <span class="cov1" title="1">return nil, fmt.Errorf("no supported platform detected in current directory")</span>
}

func FromString(platformStr string) (Platform, error) <span class="cov5" title="12">{
        switch strings.ToLower(platformStr) </span>{
        case "android":<span class="cov2" title="2">
                return &amp;AndroidPlatform{}, nil</span>
        case "ios":<span class="cov2" title="2">
                return &amp;IOSPlatform{}, nil</span>
        case "macos":<span class="cov2" title="2">
                return &amp;MacOSPlatform{}, nil</span>
        case "windows":<span class="cov2" title="2">
                return &amp;WindowsPlatform{}, nil</span>
        case "linux":<span class="cov2" title="2">
                return &amp;LinuxPlatform{}, nil</span>
        default:<span class="cov2" title="2">
                return nil, fmt.Errorf("unsupported platform: %s", platformStr)</span>
        }
}

func fileExists(path string) bool <span class="cov10" title="112">{
        _, err := os.Stat(path)
        return !os.IsNotExist(err)
}</span>

func findFile(root, pattern string) string <span class="cov8" title="54">{
        var result string
        _ = filepath.Walk(root, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="110">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov9" title="110">matched, err := filepath.Match(pattern, info.Name())
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov9" title="110">if matched </span><span class="cov5" title="9">{
                        result = path
                        return filepath.SkipDir
                }</span>
                <span class="cov9" title="101">return nil</span>
        })
        <span class="cov8" title="54">return result</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package ui

import (
        "fmt"

        "github.com/fatih/color"
)

var (
        // Primary colors for branding
        Primary   = color.New(color.FgHiBlue, color.Bold)
        Secondary = color.New(color.FgHiCyan)

        // Status colors
        Success = color.New(color.FgHiGreen, color.Bold)
        Warning = color.New(color.FgHiYellow, color.Bold)
        Error   = color.New(color.FgHiRed, color.Bold)
        Info    = color.New(color.FgHiBlue)

        // Text colors
        Bold   = color.New(color.Bold)
        Dim    = color.New(color.Faint)
        Italic = color.New(color.Italic)

        // Special colors
        Fire   = color.New(color.FgHiRed, color.Bold)
        Rocket = color.New(color.FgHiYellow, color.Bold)
        Check  = color.New(color.FgHiGreen, color.Bold)
)

// Header prints a styled header with fire emoji
func Header(text string) <span class="cov8" title="1">{
        fmt.Printf("\nüî• %s\n", Primary.Sprint(text))
}</span>

// Success prints a success message with checkmark
func SuccessMsg(text string) <span class="cov8" title="1">{
        fmt.Printf("‚úÖ %s\n", Success.Sprint(text))
}</span>

// Warning prints a warning message with warning emoji
func WarningMsg(text string) <span class="cov8" title="1">{
        fmt.Printf("‚ö†Ô∏è  %s\n", Warning.Sprint(text))
}</span>

// Error prints an error message with X emoji
func ErrorMsg(text string) <span class="cov8" title="1">{
        fmt.Printf("‚ùå %s\n", Error.Sprint(text))
}</span>

// Info prints an info message with info emoji
func InfoMsg(text string) <span class="cov8" title="1">{
        fmt.Printf("üí° %s\n", Info.Sprint(text))
}</span>

// Rocket prints a message with rocket emoji for build/deploy actions
func RocketMsg(text string) <span class="cov8" title="1">{
        fmt.Printf("üöÄ %s\n", Rocket.Sprint(text))
}</span>

// Step prints a numbered step
func Step(number int, text string) <span class="cov8" title="1">{
        fmt.Printf("%s %s\n",
                Primary.Sprintf("%d.", number),
                text)
}</span>

// Bullet prints a bullet point
func Bullet(text string) <span class="cov8" title="1">{
        fmt.Printf("  ‚Ä¢ %s\n", text)
}</span>

// Code prints text in a code-like format
func Code(text string) string <span class="cov8" title="1">{
        return Secondary.Sprintf("`%s`", text)
}</span>

// ProjectHeader prints a styled project header
func ProjectHeader(projectName string) <span class="cov8" title="1">{
        fmt.Printf("\nüî• %s %s\n",
                Primary.Sprint("Firebase Project:"),
                Bold.Sprint(projectName))
}</span>

// Platform prints platform with appropriate emoji
func Platform(platform string) string <span class="cov8" title="1">{
        var emoji string
        switch platform </span>{
        case "iOS":<span class="cov8" title="1">
                emoji = "üì±"</span>
        case "Android":<span class="cov0" title="0">
                emoji = "ü§ñ"</span>
        case "macOS":<span class="cov0" title="0">
                emoji = "üñ•Ô∏è"</span>
        case "Windows":<span class="cov0" title="0">
                emoji = "ü™ü"</span>
        case "Linux":<span class="cov0" title="0">
                emoji = "üêß"</span>
        case "Web":<span class="cov0" title="0">
                emoji = "üåê"</span>
        default:<span class="cov0" title="0">
                emoji = "üì¶"</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%s %s", emoji, Secondary.Sprint(platform))</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "github.com/clix-so/nativefire/cmd"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
